<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ailia_tflite: ailiaTFLite.AiliaTFLite Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ailia_tflite
   &#160;<span id="projectnumber">1.2.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceailiaTFLite.html">ailiaTFLite</a></li><li class="navelem"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html">AiliaTFLite</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classailiaTFLite_1_1AiliaTFLite-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ailiaTFLite.AiliaTFLite Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aef833dad703e1255061aa4294cdfe9a2"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#aef833dad703e1255061aa4294cdfe9a2">ailiaTFLiteGetEnvironmentCount</a> (ref UInt64 env_count)</td></tr>
<tr class="memdesc:aef833dad703e1255061aa4294cdfe9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of available calculation environments.  <a href="classailiaTFLite_1_1AiliaTFLite.html#aef833dad703e1255061aa4294cdfe9a2">More...</a><br /></td></tr>
<tr class="separator:aef833dad703e1255061aa4294cdfe9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0655ce15b412da17b7e70c0cd6175e7"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#af0655ce15b412da17b7e70c0cd6175e7">ailiaTFLiteGetEnvironment</a> (Int32[] env)</td></tr>
<tr class="memdesc:af0655ce15b412da17b7e70c0cd6175e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of calculation environments.  <a href="classailiaTFLite_1_1AiliaTFLite.html#af0655ce15b412da17b7e70c0cd6175e7">More...</a><br /></td></tr>
<tr class="separator:af0655ce15b412da17b7e70c0cd6175e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd5e034977674cb3655b38c5f67285d"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a4bd5e034977674cb3655b38c5f67285d">ailiaTFLiteCreate</a> (ref IntPtr instance, byte[] tflite, UInt64 tflite_length, IntPtr pmalloc, IntPtr pmemcpy, IntPtr pfree, IntPtr phandle, Int32 env_id, Int32 memory_mode, UInt32 flags)</td></tr>
<tr class="memdesc:a4bd5e034977674cb3655b38c5f67285d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create ailia TFLite runtime instances.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a4bd5e034977674cb3655b38c5f67285d">More...</a><br /></td></tr>
<tr class="separator:a4bd5e034977674cb3655b38c5f67285d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63d9b0e258c8925e4af0500d68e1002"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#ae63d9b0e258c8925e4af0500d68e1002">ailiaTFLiteDestroy</a> (IntPtr instance)</td></tr>
<tr class="memdesc:ae63d9b0e258c8925e4af0500d68e1002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard the instance of ailia TFLite runtime.  <a href="classailiaTFLite_1_1AiliaTFLite.html#ae63d9b0e258c8925e4af0500d68e1002">More...</a><br /></td></tr>
<tr class="separator:ae63d9b0e258c8925e4af0500d68e1002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a4a25234ce35c3c6274b46bc13d90e"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a46a4a25234ce35c3c6274b46bc13d90e">ailiaTFLiteGetCpuFeatures</a> (IntPtr instance, ref Int32 cpu_features)</td></tr>
<tr class="memdesc:a46a4a25234ce35c3c6274b46bc13d90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the CPU instruction to use.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a46a4a25234ce35c3c6274b46bc13d90e">More...</a><br /></td></tr>
<tr class="separator:a46a4a25234ce35c3c6274b46bc13d90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57d878e3574616ddd829c98da1677f8"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#ad57d878e3574616ddd829c98da1677f8">ailiaTFLiteSetCpuFeatures</a> (IntPtr instance, Int32 cpu_features)</td></tr>
<tr class="memdesc:ad57d878e3574616ddd829c98da1677f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CPU instruction to use.  <a href="classailiaTFLite_1_1AiliaTFLite.html#ad57d878e3574616ddd829c98da1677f8">More...</a><br /></td></tr>
<tr class="separator:ad57d878e3574616ddd829c98da1677f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebdea83b3be14fd8f99ee33abdb9c26"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a0ebdea83b3be14fd8f99ee33abdb9c26">ailiaTFLiteGetDeviceCount</a> (IntPtr instance, ref UInt64 device_count)</td></tr>
<tr class="memdesc:a0ebdea83b3be14fd8f99ee33abdb9c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of available devices.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a0ebdea83b3be14fd8f99ee33abdb9c26">More...</a><br /></td></tr>
<tr class="separator:a0ebdea83b3be14fd8f99ee33abdb9c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886aacf6cc2ad25449ce7e31c625f179"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a886aacf6cc2ad25449ce7e31c625f179">ailiaTFLiteGetDeviceName</a> (IntPtr instance, Int32 device_idx, ref IntPtr name)</td></tr>
<tr class="memdesc:a886aacf6cc2ad25449ce7e31c625f179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the specified index device.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a886aacf6cc2ad25449ce7e31c625f179">More...</a><br /></td></tr>
<tr class="separator:a886aacf6cc2ad25449ce7e31c625f179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4d8f8676f76ad96cb91a17ebd3a6bf"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a0a4d8f8676f76ad96cb91a17ebd3a6bf">ailiaTFLiteGetDeviceExtraInfo</a> (IntPtr instance, Int32 device_idx, ref IntPtr info)</td></tr>
<tr class="memdesc:a0a4d8f8676f76ad96cb91a17ebd3a6bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the detailed information of the specified index device.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a0a4d8f8676f76ad96cb91a17ebd3a6bf">More...</a><br /></td></tr>
<tr class="separator:a0a4d8f8676f76ad96cb91a17ebd3a6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a7965f3c38b5f3911e8358c86a205b"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a63a7965f3c38b5f3911e8358c86a205b">ailiaTFLiteSelectDevices</a> (IntPtr instance, Int32[] device_idxes, UInt64 idx_count)</td></tr>
<tr class="memdesc:a63a7965f3c38b5f3911e8358c86a205b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the index of the device to use.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a63a7965f3c38b5f3911e8358c86a205b">More...</a><br /></td></tr>
<tr class="separator:a63a7965f3c38b5f3911e8358c86a205b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef345e7984b3a67f82f580e46fb73463"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#aef345e7984b3a67f82f580e46fb73463">ailiaTFLiteGetSelectedDeviceIndexes</a> (IntPtr instance, Int32[] device_idxes, ref UInt64 idx_count)</td></tr>
<tr class="memdesc:aef345e7984b3a67f82f580e46fb73463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index and number of devices used.  <a href="classailiaTFLite_1_1AiliaTFLite.html#aef345e7984b3a67f82f580e46fb73463">More...</a><br /></td></tr>
<tr class="separator:aef345e7984b3a67f82f580e46fb73463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3950e0c58e61b8000879497b2739969"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#af3950e0c58e61b8000879497b2739969">ailiaTFLiteAllocateTensors</a> (IntPtr instance)</td></tr>
<tr class="memdesc:af3950e0c58e61b8000879497b2739969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure the internal buffer of ailia TFLite runtime.  <a href="classailiaTFLite_1_1AiliaTFLite.html#af3950e0c58e61b8000879497b2739969">More...</a><br /></td></tr>
<tr class="separator:af3950e0c58e61b8000879497b2739969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1491072dfb32ce268cfeba254a22fcb8"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a1491072dfb32ce268cfeba254a22fcb8">ailiaTFLiteResizeInputTensor</a> (IntPtr instance, Int32 input_index, Int32[] shape, Int32 dim)</td></tr>
<tr class="memdesc:a1491072dfb32ce268cfeba254a22fcb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the shape of Tensor of the specified input index.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a1491072dfb32ce268cfeba254a22fcb8">More...</a><br /></td></tr>
<tr class="separator:a1491072dfb32ce268cfeba254a22fcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24385f9c43317bb8219c0f22402491c8"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a24385f9c43317bb8219c0f22402491c8">ailiaTFLiteGetNumberOfInputs</a> (IntPtr instance, ref Int32 num_of_input_tensor)</td></tr>
<tr class="memdesc:a24385f9c43317bb8219c0f22402491c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of TENSOR in the TFLITE model.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a24385f9c43317bb8219c0f22402491c8">More...</a><br /></td></tr>
<tr class="separator:a24385f9c43317bb8219c0f22402491c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b55f83427a4e8de6b33dd4edeed695"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a81b55f83427a4e8de6b33dd4edeed695">ailiaTFLiteGetInputTensorIndex</a> (IntPtr instance, ref Int32 tensor_index, Int32 input_index)</td></tr>
<tr class="memdesc:a81b55f83427a4e8de6b33dd4edeed695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Tensor's index from index in Tensor.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a81b55f83427a4e8de6b33dd4edeed695">More...</a><br /></td></tr>
<tr class="separator:a81b55f83427a4e8de6b33dd4edeed695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b84585563897e9175ff86572293ef4"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a74b84585563897e9175ff86572293ef4">ailiaTFLiteGetNumberOfOutputs</a> (IntPtr instance, ref Int32 num_of_output_tensor)</td></tr>
<tr class="memdesc:a74b84585563897e9175ff86572293ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of TENSOR of the TFLITE model.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a74b84585563897e9175ff86572293ef4">More...</a><br /></td></tr>
<tr class="separator:a74b84585563897e9175ff86572293ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029cb8e7e222cf4a7cad8e461d7d2521"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a029cb8e7e222cf4a7cad8e461d7d2521">ailiaTFLiteGetOutputTensorIndex</a> (IntPtr instance, ref Int32 tensor_index, Int32 output_index)</td></tr>
<tr class="memdesc:a029cb8e7e222cf4a7cad8e461d7d2521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain Tensor's index from index of output Tensor.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a029cb8e7e222cf4a7cad8e461d7d2521">More...</a><br /></td></tr>
<tr class="separator:a029cb8e7e222cf4a7cad8e461d7d2521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c17b69682b9c2eb62224305d28ecbf"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a47c17b69682b9c2eb62224305d28ecbf">ailiaTFLiteGetTensorDimension</a> (IntPtr instance, ref Int32 tensor_dim, Int32 tensor_index)</td></tr>
<tr class="memdesc:a47c17b69682b9c2eb62224305d28ecbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of index number Tensor.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a47c17b69682b9c2eb62224305d28ecbf">More...</a><br /></td></tr>
<tr class="separator:a47c17b69682b9c2eb62224305d28ecbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332d99566bf2a4eb1c204242d6bc3e04"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a332d99566bf2a4eb1c204242d6bc3e04">ailiaTFLiteGetTensorShape</a> (IntPtr instance, Int32[] shape, Int32 tensor_index)</td></tr>
<tr class="memdesc:a332d99566bf2a4eb1c204242d6bc3e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the shape of the index number Tensor.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a332d99566bf2a4eb1c204242d6bc3e04">More...</a><br /></td></tr>
<tr class="separator:a332d99566bf2a4eb1c204242d6bc3e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b60af1aae3826865a73b0b242a9bc69"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a1b60af1aae3826865a73b0b242a9bc69">ailiaTFLiteGetTensorShapeSignature</a> (IntPtr instance, Int32[] shape, Int32 tensor_index)</td></tr>
<tr class="memdesc:a1b60af1aae3826865a73b0b242a9bc69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the undecided dimensional form of Tensor of index number.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a1b60af1aae3826865a73b0b242a9bc69">More...</a><br /></td></tr>
<tr class="separator:a1b60af1aae3826865a73b0b242a9bc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78def8ebc21d320e827f34c3cdb57231"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a78def8ebc21d320e827f34c3cdb57231">ailiaTFLiteGetTensorType</a> (IntPtr instance, ref sbyte tensor_type, Int32 tensor_index)</td></tr>
<tr class="memdesc:a78def8ebc21d320e827f34c3cdb57231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Data type of TENSOR in Index.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a78def8ebc21d320e827f34c3cdb57231">More...</a><br /></td></tr>
<tr class="separator:a78def8ebc21d320e827f34c3cdb57231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fc260a4b129770cd0abc7ec6495416"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#ab3fc260a4b129770cd0abc7ec6495416">ailiaTFLiteGetTensorBuffer</a> (IntPtr instance, ref IntPtr buffer, Int32 tensor_index)</td></tr>
<tr class="memdesc:ab3fc260a4b129770cd0abc7ec6495416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a storage buffer in Tensor's data.  <a href="classailiaTFLite_1_1AiliaTFLite.html#ab3fc260a4b129770cd0abc7ec6495416">More...</a><br /></td></tr>
<tr class="separator:ab3fc260a4b129770cd0abc7ec6495416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30893448fef225df072125b3d0db9dce"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a30893448fef225df072125b3d0db9dce">ailiaTFLiteGetTensorName</a> (IntPtr instance, ref IntPtr name, Int32 tensor_index)</td></tr>
<tr class="memdesc:a30893448fef225df072125b3d0db9dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the index number Tensor.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a30893448fef225df072125b3d0db9dce">More...</a><br /></td></tr>
<tr class="separator:a30893448fef225df072125b3d0db9dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad675cc3dfe2912fc2fdf318068ca81d2"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#ad675cc3dfe2912fc2fdf318068ca81d2">ailiaTFLiteGetTensorQuantizationCount</a> (IntPtr instance, ref Int32 count, Int32 tensor_index)</td></tr>
<tr class="memdesc:ad675cc3dfe2912fc2fdf318068ca81d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of quantified parameters of index number Tensor.  <a href="classailiaTFLite_1_1AiliaTFLite.html#ad675cc3dfe2912fc2fdf318068ca81d2">More...</a><br /></td></tr>
<tr class="separator:ad675cc3dfe2912fc2fdf318068ca81d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c97829408d061fb051586b8488818a"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a86c97829408d061fb051586b8488818a">ailiaTFLiteGetTensorQuantizationScale</a> (IntPtr instance, float[] scale, Int32 tensor_index)</td></tr>
<tr class="memdesc:a86c97829408d061fb051586b8488818a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scale of the quantified parameter of the index number TENSOR.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a86c97829408d061fb051586b8488818a">More...</a><br /></td></tr>
<tr class="separator:a86c97829408d061fb051586b8488818a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb252076a9f466c1511f9aa24e7c63f"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a9bb252076a9f466c1511f9aa24e7c63f">ailiaTFLiteGetTensorQuantizationZeroPoint</a> (IntPtr instance, Int64[] zero_point, Int32 tensor_index)</td></tr>
<tr class="memdesc:a9bb252076a9f466c1511f9aa24e7c63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the zero point of the quantified parameter of the index number TENSOR.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a9bb252076a9f466c1511f9aa24e7c63f">More...</a><br /></td></tr>
<tr class="separator:a9bb252076a9f466c1511f9aa24e7c63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7725f3fcc2100ee9d5dd2173cea2dd29"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a7725f3fcc2100ee9d5dd2173cea2dd29">ailiaTFLiteGetTensorQuantizationQuantizedDimension</a> (IntPtr instance, ref Int32 axis, Int32 tensor_index)</td></tr>
<tr class="memdesc:a7725f3fcc2100ee9d5dd2173cea2dd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the axis of the integrated TENSOR quantization parameter.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a7725f3fcc2100ee9d5dd2173cea2dd29">More...</a><br /></td></tr>
<tr class="separator:a7725f3fcc2100ee9d5dd2173cea2dd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8bc6ebc4badf1c3cdc28b8c8e3c3108"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#ae8bc6ebc4badf1c3cdc28b8c8e3c3108">ailiaTFLitePredict</a> (IntPtr instance)</td></tr>
<tr class="memdesc:ae8bc6ebc4badf1c3cdc28b8c8e3c3108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do inference.  <a href="classailiaTFLite_1_1AiliaTFLite.html#ae8bc6ebc4badf1c3cdc28b8c8e3c3108">More...</a><br /></td></tr>
<tr class="separator:ae8bc6ebc4badf1c3cdc28b8c8e3c3108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68428a2cebef9ee085e2833233386103"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a68428a2cebef9ee085e2833233386103">ailiaTFLiteGetNodeCount</a> (IntPtr instance, ref Int32 count)</td></tr>
<tr class="memdesc:a68428a2cebef9ee085e2833233386103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of node.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a68428a2cebef9ee085e2833233386103">More...</a><br /></td></tr>
<tr class="separator:a68428a2cebef9ee085e2833233386103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22f6d01c7aa1afe2323bccd3431e28d"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#aa22f6d01c7aa1afe2323bccd3431e28d">ailiaTFLiteGetNodeOperator</a> (IntPtr instance, ref Int32 op, Int32 node_index)</td></tr>
<tr class="memdesc:aa22f6d01c7aa1afe2323bccd3431e28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node_index number Operator.  <a href="classailiaTFLite_1_1AiliaTFLite.html#aa22f6d01c7aa1afe2323bccd3431e28d">More...</a><br /></td></tr>
<tr class="separator:aa22f6d01c7aa1afe2323bccd3431e28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f27553f38b780fe8ae97c19e91c8445"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a4f27553f38b780fe8ae97c19e91c8445">ailiaTFLiteGetNodeInputCount</a> (IntPtr instance, ref Int32 count, Int32 node_index)</td></tr>
<tr class="memdesc:a4f27553f38b780fe8ae97c19e91c8445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node_index gets the number of node input.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a4f27553f38b780fe8ae97c19e91c8445">More...</a><br /></td></tr>
<tr class="separator:a4f27553f38b780fe8ae97c19e91c8445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d780525c2fc94c90222210a87b61bb4"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a4d780525c2fc94c90222210a87b61bb4">ailiaTFLiteGetNodeInputTensorIndex</a> (IntPtr instance, ref Int32 tensor_index, Int32 node_index, Int32 input_index)</td></tr>
<tr class="memdesc:a4d780525c2fc94c90222210a87b61bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node_index Acquires the index of Tensor in the input input of node.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a4d780525c2fc94c90222210a87b61bb4">More...</a><br /></td></tr>
<tr class="separator:a4d780525c2fc94c90222210a87b61bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78f86546cd49ff6753727ca41a3d69a"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#ad78f86546cd49ff6753727ca41a3d69a">ailiaTFLiteGetNodeOutputCount</a> (IntPtr instance, ref Int32 count, Int32 node_index)</td></tr>
<tr class="memdesc:ad78f86546cd49ff6753727ca41a3d69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node_index gets the number of node output.  <a href="classailiaTFLite_1_1AiliaTFLite.html#ad78f86546cd49ff6753727ca41a3d69a">More...</a><br /></td></tr>
<tr class="separator:ad78f86546cd49ff6753727ca41a3d69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd20b80f52a077942b213ddac4b9aed"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#addd20b80f52a077942b213ddac4b9aed">ailiaTFLiteGetNodeOutputTensorIndex</a> (IntPtr instance, ref Int32 tensor_index, Int32 node_index, Int32 output_index)</td></tr>
<tr class="separator:addd20b80f52a077942b213ddac4b9aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63183e3cd0ee31eea608b96aa634090a"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a63183e3cd0ee31eea608b96aa634090a">ailiaTFLiteGetNodeOption</a> (IntPtr instance, IntPtr value, Int32 node_index, string key)</td></tr>
<tr class="separator:a63183e3cd0ee31eea608b96aa634090a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc4a3dc97431d79109280d0460b5a67"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a0bc4a3dc97431d79109280d0460b5a67">ailiaTFLiteGetOperatorName</a> (ref IntPtr name, Int32 op)</td></tr>
<tr class="separator:a0bc4a3dc97431d79109280d0460b5a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacedc064dca9aed31393a5dcc953784d"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#aacedc064dca9aed31393a5dcc953784d">ailiaTFLiteSetProfileMode</a> (IntPtr instance, Int32 mode)</td></tr>
<tr class="memdesc:aacedc064dca9aed31393a5dcc953784d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the profile mode.  <a href="classailiaTFLite_1_1AiliaTFLite.html#aacedc064dca9aed31393a5dcc953784d">More...</a><br /></td></tr>
<tr class="separator:aacedc064dca9aed31393a5dcc953784d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8af78695cde0ac7757cc885f33e685"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a0e8af78695cde0ac7757cc885f33e685">ailiaTFLiteGetSummaryLength</a> (IntPtr instance, ref UInt64 buffer_size)</td></tr>
<tr class="memdesc:a0e8af78695cde0ac7757cc885f33e685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the buffer required for network Summary.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a0e8af78695cde0ac7757cc885f33e685">More...</a><br /></td></tr>
<tr class="separator:a0e8af78695cde0ac7757cc885f33e685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64768b45a40406cea12799c264775eb8"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a64768b45a40406cea12799c264775eb8">ailiaTFLiteGetSummary</a> (IntPtr instance, byte[] buffer, UInt64 buffer_size)</td></tr>
<tr class="memdesc:a64768b45a40406cea12799c264775eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the name and shape of each node.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a64768b45a40406cea12799c264775eb8">More...</a><br /></td></tr>
<tr class="separator:a64768b45a40406cea12799c264775eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc52daded05cba47284695cf1c49a306"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#abc52daded05cba47284695cf1c49a306">ailiaTFLiteGetErrorDetail</a> (IntPtr instance, ref IntPtr buffer)</td></tr>
<tr class="memdesc:abc52daded05cba47284695cf1c49a306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error details.  <a href="classailiaTFLite_1_1AiliaTFLite.html#abc52daded05cba47284695cf1c49a306">More...</a><br /></td></tr>
<tr class="separator:abc52daded05cba47284695cf1c49a306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a0e8cb6117e144c037b610d9550586"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a25a0e8cb6117e144c037b610d9550586">ailiaTFLiteSetScratchBuffer</a> (IntPtr instance, IntPtr int_buffer, UInt64 int_buffer_size, IntPtr mid_buffer, UInt64 mid_buffer_size, IntPtr ext_buffer, UInt64 ext_buffer_size)</td></tr>
<tr class="memdesc:a25a0e8cb6117e144c037b610d9550586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a scratch buffer.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a25a0e8cb6117e144c037b610d9550586">More...</a><br /></td></tr>
<tr class="separator:a25a0e8cb6117e144c037b610d9550586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29bf832951ede1b50c01e900fc6fc225"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a29bf832951ede1b50c01e900fc6fc225">ailiaTFLiteGetScratchBufferUsage</a> (IntPtr instance, ref UInt64 int_buffer_size, ref UInt64 mid_buffer_size, ref UInt64 ext_buffer_size)</td></tr>
<tr class="memdesc:a29bf832951ede1b50c01e900fc6fc225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum usage of the scratch buffer.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a29bf832951ede1b50c01e900fc6fc225">More...</a><br /></td></tr>
<tr class="separator:a29bf832951ede1b50c01e900fc6fc225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3a58e04451a1fe12124be27b0881b0"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a2d3a58e04451a1fe12124be27b0881b0">ailiaTFLiteMklSetNumThreads</a> (Int32 num_threads)</td></tr>
<tr class="memdesc:a2d3a58e04451a1fe12124be27b0881b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of threads used by MKL.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a2d3a58e04451a1fe12124be27b0881b0">More...</a><br /></td></tr>
<tr class="separator:a2d3a58e04451a1fe12124be27b0881b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7ea1137df13888dd7a8b080d447cc4"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#aae7ea1137df13888dd7a8b080d447cc4">ailiaTFLiteMklDisableFastMM</a> ()</td></tr>
<tr class="memdesc:aae7ea1137df13888dd7a8b080d447cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the mkl fastmm.  <a href="classailiaTFLite_1_1AiliaTFLite.html#aae7ea1137df13888dd7a8b080d447cc4">More...</a><br /></td></tr>
<tr class="separator:aae7ea1137df13888dd7a8b080d447cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6209e4877400f1401da1c87e101d90"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a8b6209e4877400f1401da1c87e101d90">ailiaTFLiteGetVersion</a> ()</td></tr>
<tr class="memdesc:a8b6209e4877400f1401da1c87e101d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the library version.  <a href="classailiaTFLite_1_1AiliaTFLite.html#a8b6209e4877400f1401da1c87e101d90">More...</a><br /></td></tr>
<tr class="separator:a8b6209e4877400f1401da1c87e101d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a249bb296bf247e96053d97373c18e0ec"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a249bb296bf247e96053d97373c18e0ec">AILIA_TFLITE_TENSOR_TYPE_FLOAT32</a> =( 0)</td></tr>
<tr class="separator:a249bb296bf247e96053d97373c18e0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa05ecaf560a809162731ddff9dd473"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a9fa05ecaf560a809162731ddff9dd473">AILIA_TFLITE_TENSOR_TYPE_FLOAT16</a> =( 1)</td></tr>
<tr class="separator:a9fa05ecaf560a809162731ddff9dd473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1926bfe7a4efc83ec097d7fa0626858b"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a1926bfe7a4efc83ec097d7fa0626858b">AILIA_TFLITE_TENSOR_TYPE_INT32</a> =( 2)</td></tr>
<tr class="separator:a1926bfe7a4efc83ec097d7fa0626858b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fce41722ce0f3b61a7374b5e006194"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#ad9fce41722ce0f3b61a7374b5e006194">AILIA_TFLITE_TENSOR_TYPE_UINT8</a> =( 3)</td></tr>
<tr class="separator:ad9fce41722ce0f3b61a7374b5e006194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b84757f549ed1e98bbace73e41ccfc6"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a4b84757f549ed1e98bbace73e41ccfc6">AILIA_TFLITE_TENSOR_TYPE_INT64</a> =( 4)</td></tr>
<tr class="separator:a4b84757f549ed1e98bbace73e41ccfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2aa76d3c735180d6f078959f037ade"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#adb2aa76d3c735180d6f078959f037ade">AILIA_TFLITE_TENSOR_TYPE_STRING</a> =( 5)</td></tr>
<tr class="separator:adb2aa76d3c735180d6f078959f037ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0383238abcb8e792c5a8ab0c049211a9"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a0383238abcb8e792c5a8ab0c049211a9">AILIA_TFLITE_TENSOR_TYPE_BOOL</a> =( 6)</td></tr>
<tr class="separator:a0383238abcb8e792c5a8ab0c049211a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9553cd68853012670d0fb9f39162256"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#ac9553cd68853012670d0fb9f39162256">AILIA_TFLITE_TENSOR_TYPE_INT16</a> =( 7)</td></tr>
<tr class="separator:ac9553cd68853012670d0fb9f39162256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec298e888687e44f4eabcd05409743d0"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#aec298e888687e44f4eabcd05409743d0">AILIA_TFLITE_TENSOR_TYPE_COMPLEX64</a> =( 8)</td></tr>
<tr class="separator:aec298e888687e44f4eabcd05409743d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83c7e50d6b0dce6a0d5caf85483b52b"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#ae83c7e50d6b0dce6a0d5caf85483b52b">AILIA_TFLITE_TENSOR_TYPE_INT8</a> =( 9)</td></tr>
<tr class="separator:ae83c7e50d6b0dce6a0d5caf85483b52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd7d6f04e4797113de08db39c5f6c17"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a1cd7d6f04e4797113de08db39c5f6c17">AILIA_TFLITE_STATUS_SUCCESS</a> =( 0)</td></tr>
<tr class="separator:a1cd7d6f04e4797113de08db39c5f6c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c3ef4510e92e0a9f05e5c69a48c1ba"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#ad4c3ef4510e92e0a9f05e5c69a48c1ba">AILIA_TFLITE_STATUS_INVALID_ARGUMENT</a> =( -1)</td></tr>
<tr class="separator:ad4c3ef4510e92e0a9f05e5c69a48c1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5f04d2d998e295856cab9c3528c018"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a5b5f04d2d998e295856cab9c3528c018">AILIA_TFLITE_STATUS_OUT_OF_RANGE</a> =( -2)</td></tr>
<tr class="separator:a5b5f04d2d998e295856cab9c3528c018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19bc164f32622a16e995d98ec2974ad"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#ac19bc164f32622a16e995d98ec2974ad">AILIA_TFLITE_STATUS_MEMORY_INSUFFICIENT</a> =( -3)</td></tr>
<tr class="separator:ac19bc164f32622a16e995d98ec2974ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b2d4ea1afc1cbe8fac752fd62cf4d9"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a53b2d4ea1afc1cbe8fac752fd62cf4d9">AILIA_TFLITE_STATUS_BROKEN_MODEL</a> =( -4)</td></tr>
<tr class="separator:a53b2d4ea1afc1cbe8fac752fd62cf4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4bee81697d5cc30e5aa28efca018f6"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#adc4bee81697d5cc30e5aa28efca018f6">AILIA_TFLITE_STATUS_INVALID_PARAMETER</a> =( -5)</td></tr>
<tr class="separator:adc4bee81697d5cc30e5aa28efca018f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d4e404e1f537d98418e0df911667db"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a80d4e404e1f537d98418e0df911667db">AILIA_TFLITE_STATUS_PARAMETER_NOT_FOUND</a> =( -6)</td></tr>
<tr class="separator:a80d4e404e1f537d98418e0df911667db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eaa85237328b48ad7aa0e6cd4892c06"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a9eaa85237328b48ad7aa0e6cd4892c06">AILIA_TFLITE_STATUS_UNSUPPORTED_OPCODE</a> =( -7)</td></tr>
<tr class="separator:a9eaa85237328b48ad7aa0e6cd4892c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327c0a483c7ca50a58af8e62a1363206"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a327c0a483c7ca50a58af8e62a1363206">AILIA_TFLITE_STATUS_LICENSE_NOT_FOUND</a> =( -8)</td></tr>
<tr class="separator:a327c0a483c7ca50a58af8e62a1363206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18285d00e2513e8dd7ab9f27560e79de"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a18285d00e2513e8dd7ab9f27560e79de">AILIA_TFLITE_STATUS_LICENSE_BROKEN</a> =( -9)</td></tr>
<tr class="separator:a18285d00e2513e8dd7ab9f27560e79de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7319186274d06241d5189884e8becb8"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#ae7319186274d06241d5189884e8becb8">AILIA_TFLITE_STATUS_LICENSE_EXPIRED</a> =( -10)</td></tr>
<tr class="separator:ae7319186274d06241d5189884e8becb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdce02eb28d01fcb943d24253ff8355e"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#afdce02eb28d01fcb943d24253ff8355e">AILIA_TFLITE_STATUS_INVALID_STATE</a> =( -11)</td></tr>
<tr class="separator:afdce02eb28d01fcb943d24253ff8355e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce504dd854c09e3aa98ffc56f0e501f"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a8ce504dd854c09e3aa98ffc56f0e501f">AILIA_TFLITE_STATUS_OTHER_ERROR</a> =(-128)</td></tr>
<tr class="separator:a8ce504dd854c09e3aa98ffc56f0e501f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15faf8b6ae7f09033c8bbdc65869bd86"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a15faf8b6ae7f09033c8bbdc65869bd86">AILIA_TFLITE_ENV_REFERENCE</a> =( 0)</td></tr>
<tr class="separator:a15faf8b6ae7f09033c8bbdc65869bd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a494804119cd442387ca642d6c3c67"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a06a494804119cd442387ca642d6c3c67">AILIA_TFLITE_ENV_NNAPI</a> =( 1)</td></tr>
<tr class="separator:a06a494804119cd442387ca642d6c3c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdee302a310f5b3eb98f0ff0fb721ee2"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#afdee302a310f5b3eb98f0ff0fb721ee2">AILIA_TFLITE_ENV_MMALIB</a> =( 2)</td></tr>
<tr class="separator:afdee302a310f5b3eb98f0ff0fb721ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0534b59fd05c17763f680f07bc5baa3"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#ac0534b59fd05c17763f680f07bc5baa3">AILIA_TFLITE_ENV_MMALIB_COMPATIBLE</a> =( 3)</td></tr>
<tr class="separator:ac0534b59fd05c17763f680f07bc5baa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa880471a31408f974f8270f5b2c0ada"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#afa880471a31408f974f8270f5b2c0ada">AILIA_TFLITE_MEMORY_MODE_DEFAULT</a> =( 0)</td></tr>
<tr class="separator:afa880471a31408f974f8270f5b2c0ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd64b3267e61700d0881987556ec5f3"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a1cd64b3267e61700d0881987556ec5f3">AILIA_TFLITE_MEMORY_MODE_REDUCE_INTERSTAGE</a> =( 1)</td></tr>
<tr class="separator:a1cd64b3267e61700d0881987556ec5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd19c81a9dc7aaded9d380500207fc4"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a5bd19c81a9dc7aaded9d380500207fc4">AILIA_TFLITE_PROFILE_MODE_DISABLE</a> =( 0)</td></tr>
<tr class="separator:a5bd19c81a9dc7aaded9d380500207fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8e1aac6c3d03d1103ca72ac1840ebf"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a2a8e1aac6c3d03d1103ca72ac1840ebf">AILIA_TFLITE_PROFILE_MODE_ENABLE</a> =( 1)</td></tr>
<tr class="separator:a2a8e1aac6c3d03d1103ca72ac1840ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4132271e5372f4fd0767f6c0012bfb"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a1c4132271e5372f4fd0767f6c0012bfb">AILIA_TFLITE_PROFILE_MODE_TRACE</a> =( 2)</td></tr>
<tr class="separator:a1c4132271e5372f4fd0767f6c0012bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae544ea8aab326a32719e1d0bf4f7a6b2"><td class="memItemLeft" align="right" valign="top">const Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#ae544ea8aab326a32719e1d0bf4f7a6b2">AILIA_TFLITE_PROFILE_MODE_MEMORY</a> =( 4)</td></tr>
<tr class="separator:ae544ea8aab326a32719e1d0bf4f7a6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd56b5ac33c8b3476d1c8b5092b022c"><td class="memItemLeft" align="right" valign="top">const UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a9cd56b5ac33c8b3476d1c8b5092b022c">AILIA_TFLITE_FLAG_NONE</a> =( 0)</td></tr>
<tr class="separator:a9cd56b5ac33c8b3476d1c8b5092b022c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad568df436230c4dc073d180b2c4695a8"><td class="memItemLeft" align="right" valign="top">const UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#ad568df436230c4dc073d180b2c4695a8">AILIA_TFLITE_FLAG_INPUT_AND_OUTPUT_TENSORS_USE_SCRATCH</a> =( 1)</td></tr>
<tr class="separator:ad568df436230c4dc073d180b2c4695a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed32265479495ecec8965aaa4a780d7a"><td class="memItemLeft" align="right" valign="top">const UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#aed32265479495ecec8965aaa4a780d7a">AILIA_TFLITE_CPU_FEATURES_NONE</a> =(0x00000000)</td></tr>
<tr class="separator:aed32265479495ecec8965aaa4a780d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05517e60528ac6483e197882ccaa9d9d"><td class="memItemLeft" align="right" valign="top">const UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a05517e60528ac6483e197882ccaa9d9d">AILIA_TFLITE_CPU_FEATURES_NEON</a> =(0x00000001)</td></tr>
<tr class="separator:a05517e60528ac6483e197882ccaa9d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3502e306d8ed3a67d910a938bdb02798"><td class="memItemLeft" align="right" valign="top">const UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a3502e306d8ed3a67d910a938bdb02798">AILIA_TFLITE_CPU_FEATURES_SSE2</a> =(0x00000002)</td></tr>
<tr class="separator:a3502e306d8ed3a67d910a938bdb02798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974cbf695d26cc47548b723e798e4dd7"><td class="memItemLeft" align="right" valign="top">const UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a974cbf695d26cc47548b723e798e4dd7">AILIA_TFLITE_CPU_FEATURES_SSE4_2</a> =(0x00000004)</td></tr>
<tr class="separator:a974cbf695d26cc47548b723e798e4dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8ba1170b23eff39f722dd25e22bf3f"><td class="memItemLeft" align="right" valign="top">const UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a2c8ba1170b23eff39f722dd25e22bf3f">AILIA_TFLITE_CPU_FEATURES_AVX</a> =(0x00000008)</td></tr>
<tr class="separator:a2c8ba1170b23eff39f722dd25e22bf3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3a6b5603cb2ca0fb3a6da32d40c3bd"><td class="memItemLeft" align="right" valign="top">const UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#aae3a6b5603cb2ca0fb3a6da32d40c3bd">AILIA_TFLITE_CPU_FEATURES_AVX2</a> =(0x00000010)</td></tr>
<tr class="separator:aae3a6b5603cb2ca0fb3a6da32d40c3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae339652ad5196d43753bfb001128de"><td class="memItemLeft" align="right" valign="top">const UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#aaae339652ad5196d43753bfb001128de">AILIA_TFLITE_CPU_FEATURES_VNNI</a> =(0x00000020)</td></tr>
<tr class="separator:aaae339652ad5196d43753bfb001128de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38b42b14ba66a50e5fa9014077b479f"><td class="memItemLeft" align="right" valign="top">const String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#ab38b42b14ba66a50e5fa9014077b479f">LIBRARY_NAME</a> =&quot;ailia_tflite&quot;</td></tr>
<tr class="separator:ab38b42b14ba66a50e5fa9014077b479f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af3950e0c58e61b8000879497b2739969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3950e0c58e61b8000879497b2739969">&#9670;&nbsp;</a></span>ailiaTFLiteAllocateTensors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteAllocateTensors </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure the internal buffer of ailia TFLite runtime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Update the internal shape and secure the buffer required for inference. </p>

</div>
</div>
<a id="a4bd5e034977674cb3655b38c5f67285d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd5e034977674cb3655b38c5f67285d">&#9670;&nbsp;</a></span>ailiaTFLiteCreate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteCreate </td>
          <td>(</td>
          <td class="paramtype">ref IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>tflite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt64&#160;</td>
          <td class="paramname"><em>tflite_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>pmalloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>pmemcpy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>pfree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>phandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>env_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>memory_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create ailia TFLite runtime instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime Pointter to instance pointer </td></tr>
    <tr><td class="paramname">tflite</td><td>Pointter to TFLITE model </td></tr>
    <tr><td class="paramname">tflite_length</td><td>TFLITE length (byte unit) </td></tr>
    <tr><td class="paramname">pmalloc</td><td>MALLOC function pointer (use malloc in the case of null) </td></tr>
    <tr><td class="paramname">pmemcpy</td><td>MEMCPY function pointer (use Memcpy for null) </td></tr>
    <tr><td class="paramname">pfree</td><td>FREE function pointer (use free in the case of null) </td></tr>
    <tr><td class="paramname">phandle</td><td>Handle passed to Memoria Locator (NULL when using standard allocator) </td></tr>
    <tr><td class="paramname">env_id</td><td>Progress execution environment used for calculation (AILIA_TFLITE_ENV_NAPI_*) </td></tr>
    <tr><td class="paramname">memory_mode</td><td>Memory mode (AILIA_TFLITE_MEMORY_MODE_*) </td></tr>
    <tr><td class="paramname">flags</td><td>Flag (logical sum of AILIA_TFLITE_FLAG_*) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Open the TFLITE model and create ailia TFLite runtime instances. We will also secure the necessary internal buffers. If the instance fails, you need to call AILIATFLITEDESTROY if you store anything other than NULL in Instance. </p>

</div>
</div>
<a id="ae63d9b0e258c8925e4af0500d68e1002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63d9b0e258c8925e4af0500d68e1002">&#9670;&nbsp;</a></span>ailiaTFLiteDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ailiaTFLite.AiliaTFLite.ailiaTFLiteDestroy </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discard the instance of ailia TFLite runtime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46a4a25234ce35c3c6274b46bc13d90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a4a25234ce35c3c6274b46bc13d90e">&#9670;&nbsp;</a></span>ailiaTFLiteGetCpuFeatures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetCpuFeatures </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref Int32&#160;</td>
          <td class="paramname"><em>cpu_features</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the CPU instruction to use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">cpu_features</td><td>AILIA_TFLITE_CPU_FEATURES_XXX logical sum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Get the CPU instruction to use. By default, it returns the CPU instruction obtained from the CPU information. After calling ailiaTFLiteSetCpuFeatures, return the set CPU instruction. </p>

</div>
</div>
<a id="a0ebdea83b3be14fd8f99ee33abdb9c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebdea83b3be14fd8f99ee33abdb9c26">&#9670;&nbsp;</a></span>ailiaTFLiteGetDeviceCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetDeviceCount </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref UInt64&#160;</td>
          <td class="paramname"><em>device_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of available devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">device_count</td><td>Device storage destination </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Get the number of available devices. </p>

</div>
</div>
<a id="a0a4d8f8676f76ad96cb91a17ebd3a6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4d8f8676f76ad96cb91a17ebd3a6bf">&#9670;&nbsp;</a></span>ailiaTFLiteGetDeviceExtraInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetDeviceExtraInfo </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>device_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref IntPtr&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the detailed information of the specified index device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">device_idx</td><td>Index number in the number acquired by AILIATFLITEGETDEVICECOUNT () </td></tr>
    <tr><td class="paramname">info</td><td>Detailed information of the device information string storage destination </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Get the detailed information of the specified index device. </p>

</div>
</div>
<a id="a886aacf6cc2ad25449ce7e31c625f179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886aacf6cc2ad25449ce7e31c625f179">&#9670;&nbsp;</a></span>ailiaTFLiteGetDeviceName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetDeviceName </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>device_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref IntPtr&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the specified index device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">device_idx</td><td>Index number in the number acquired by AILIATFLITEGETDEVICECOUNT () </td></tr>
    <tr><td class="paramname">name</td><td>Device storage destination with the name of the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Get the name of the specified index device. </p>

</div>
</div>
<a id="af0655ce15b412da17b7e70c0cd6175e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0655ce15b412da17b7e70c0cd6175e7">&#9670;&nbsp;</a></span>ailiaTFLiteGetEnvironment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetEnvironment </td>
          <td>(</td>
          <td class="paramtype">Int32[]&#160;</td>
          <td class="paramname"><em>env</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of calculation environments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Arrangement of storage destination of calculation environmental information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Give the size of the <a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#aef833dad703e1255061aa4294cdfe9a2" title="Get the number of available calculation environments.">ailiaTFLiteGetEnvironmentCount()</a> to input to the input. </p>

</div>
</div>
<a id="aef833dad703e1255061aa4294cdfe9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef833dad703e1255061aa4294cdfe9a2">&#9670;&nbsp;</a></span>ailiaTFLiteGetEnvironmentCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetEnvironmentCount </td>
          <td>(</td>
          <td class="paramtype">ref UInt64&#160;</td>
          <td class="paramname"><em>env_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of available calculation environments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env_count</td><td>Pointter to the number of calculation environment information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="abc52daded05cba47284695cf1c49a306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc52daded05cba47284695cf1c49a306">&#9670;&nbsp;</a></span>ailiaTFLiteGetErrorDetail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetErrorDetail </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the error details. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">buffer</td><td>Error detailed pointer to string</td></tr>
  </table>
  </dd>
</dl>
<p>The string does not need to be released. The validity period of the string is to call the AILIA API. </p>

</div>
</div>
<a id="a81b55f83427a4e8de6b33dd4edeed695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b55f83427a4e8de6b33dd4edeed695">&#9670;&nbsp;</a></span>ailiaTFLiteGetInputTensorIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetInputTensorIndex </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref Int32&#160;</td>
          <td class="paramname"><em>tensor_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>input_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Tensor's index from index in Tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Pointer to the destination of Tensor's index </td></tr>
    <tr><td class="paramname">input_index</td><td>INDEX of input Tensor (0 ~ Number of input Tensor-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If INPUT_INDEX is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Convert from index in Tensor to index of Tensor. The upper limit of INDEX is <a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a24385f9c43317bb8219c0f22402491c8" title="Get the number of TENSOR in the TFLITE model.">ailiaTFLiteGetNumberOfInputs()</a> -1. </p>

</div>
</div>
<a id="a68428a2cebef9ee085e2833233386103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68428a2cebef9ee085e2833233386103">&#9670;&nbsp;</a></span>ailiaTFLiteGetNodeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetNodeCount </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref Int32&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">count</td><td>Pointter to the number of node stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="a4f27553f38b780fe8ae97c19e91c8445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f27553f38b780fe8ae97c19e91c8445">&#9670;&nbsp;</a></span>ailiaTFLiteGetNodeInputCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetNodeInputCount </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref Int32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>node_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node_index gets the number of node input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">count</td><td>Pointter to the storage destination of the number of input </td></tr>
    <tr><td class="paramname">node_index</td><td>Node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If node_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="a4d780525c2fc94c90222210a87b61bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d780525c2fc94c90222210a87b61bb4">&#9670;&nbsp;</a></span>ailiaTFLiteGetNodeInputTensorIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetNodeInputTensorIndex </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref Int32&#160;</td>
          <td class="paramname"><em>tensor_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>node_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>input_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node_index Acquires the index of Tensor in the input input of node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Pointer to the destination of Tensor's index </td></tr>
    <tr><td class="paramname">node_index</td><td>Node index </td></tr>
    <tr><td class="paramname">input_index</td><td>INDEX for input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If node_index and input_index are out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="aa22f6d01c7aa1afe2323bccd3431e28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22f6d01c7aa1afe2323bccd3431e28d">&#9670;&nbsp;</a></span>ailiaTFLiteGetNodeOperator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetNodeOperator </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref Int32&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>node_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get node_index number Operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">op</td><td>Pointter to the destination of Operator </td></tr>
    <tr><td class="paramname">node_index</td><td>Node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If node_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>The ENUM value of Operator is the same as the internal value of the TFLite file. For more information, see TensorFlow/Lite/Schema/Schema.fbs files in TensorFlow source tree. </p>

</div>
</div>
<a id="a63183e3cd0ee31eea608b96aa634090a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63183e3cd0ee31eea608b96aa634090a">&#9670;&nbsp;</a></span>ailiaTFLiteGetNodeOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetNodeOption </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>node_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad78f86546cd49ff6753727ca41a3d69a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78f86546cd49ff6753727ca41a3d69a">&#9670;&nbsp;</a></span>ailiaTFLiteGetNodeOutputCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetNodeOutputCount </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref Int32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>node_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node_index gets the number of node output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">count</td><td>Pointter to the storage destination of the number of output </td></tr>
    <tr><td class="paramname">node_index</td><td>Node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If node_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="addd20b80f52a077942b213ddac4b9aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd20b80f52a077942b213ddac4b9aed">&#9670;&nbsp;</a></span>ailiaTFLiteGetNodeOutputTensorIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetNodeOutputTensorIndex </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref Int32&#160;</td>
          <td class="paramname"><em>tensor_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>node_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>output_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24385f9c43317bb8219c0f22402491c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24385f9c43317bb8219c0f22402491c8">&#9670;&nbsp;</a></span>ailiaTFLiteGetNumberOfInputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetNumberOfInputs </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref Int32&#160;</td>
          <td class="paramname"><em>num_of_input_tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of TENSOR in the TFLITE model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">num_of_input_tensor</td><td>Pointter to the number of model input TENSOR </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="a74b84585563897e9175ff86572293ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b84585563897e9175ff86572293ef4">&#9670;&nbsp;</a></span>ailiaTFLiteGetNumberOfOutputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetNumberOfOutputs </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref Int32&#160;</td>
          <td class="paramname"><em>num_of_output_tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of TENSOR of the TFLITE model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">num_of_output_tensor</td><td>Pointter to the number of model output TENSOR </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="a0bc4a3dc97431d79109280d0460b5a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc4a3dc97431d79109280d0460b5a67">&#9670;&nbsp;</a></span>ailiaTFLiteGetOperatorName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetOperatorName </td>
          <td>(</td>
          <td class="paramtype">ref IntPtr&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a029cb8e7e222cf4a7cad8e461d7d2521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029cb8e7e222cf4a7cad8e461d7d2521">&#9670;&nbsp;</a></span>ailiaTFLiteGetOutputTensorIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetOutputTensorIndex </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref Int32&#160;</td>
          <td class="paramname"><em>tensor_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>output_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain Tensor's index from index of output Tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Pointer to the destination of Tensor's index </td></tr>
    <tr><td class="paramname">output_index</td><td>Output TENSOR index (0 ~ Number of output Tensor-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If output_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Convert from Index in Tensor to Tensor Index. The upper limit of INDEX is ailiaTFLiteGetNumberOfOutputs () -1. </p>

</div>
</div>
<a id="a29bf832951ede1b50c01e900fc6fc225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29bf832951ede1b50c01e900fc6fc225">&#9670;&nbsp;</a></span>ailiaTFLiteGetScratchBufferUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetScratchBufferUsage </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref UInt64&#160;</td>
          <td class="paramname"><em>int_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref UInt64&#160;</td>
          <td class="paramname"><em>mid_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref UInt64&#160;</td>
          <td class="paramname"><em>ext_buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum usage of the scratch buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">int_buffer_size</td><td>Size of scratch buffer (L2) </td></tr>
    <tr><td class="paramname">mid_buffer_size</td><td>Size of scratch buffer (MSMC) </td></tr>
    <tr><td class="paramname">ext_buffer_size</td><td>Size of scratch buffer (DDR)</td></tr>
  </table>
  </dd>
</dl>
<p>You can get the size of the necessary scratch buffer by inferring in the first large scratch buffer size. Since the value considering the alignment performed inside is returned, the acquired value can be used directly without considering the alignment. </p>

</div>
</div>
<a id="aef345e7984b3a67f82f580e46fb73463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef345e7984b3a67f82f580e46fb73463">&#9670;&nbsp;</a></span>ailiaTFLiteGetSelectedDeviceIndexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetSelectedDeviceIndexes </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32[]&#160;</td>
          <td class="paramname"><em>device_idxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref UInt64&#160;</td>
          <td class="paramname"><em>idx_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index and number of devices used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">device_idxes</td><td>A array that store indexes.Prepare an array with the maximum number of obtained in AILIATFLITEGETDEVICECOUNT (). </td></tr>
    <tr><td class="paramname">idx_count</td><td>Destination of the number of arrays </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Get the index and number of devices used. </p>

</div>
</div>
<a id="a64768b45a40406cea12799c264775eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64768b45a40406cea12799c264775eb8">&#9670;&nbsp;</a></span>ailiaTFLiteGetSummary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetSummary </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt64&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the name and shape of each node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">buffer</td><td>SUMMARY output string pointer </td></tr>
    <tr><td class="paramname">buffer_size</td><td>The size of the output buffer (including the terminal NULL character).Set the value obtained by AILIATFLITITEGETSUMMARYLENGTH (). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="a0e8af78695cde0ac7757cc885f33e685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8af78695cde0ac7757cc885f33e685">&#9670;&nbsp;</a></span>ailiaTFLiteGetSummaryLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetSummaryLength </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref UInt64&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the buffer required for network Summary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">buffer_size</td><td>Pointter to the storage destination of the size of the buffer (including the terminal NULL character) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="ab3fc260a4b129770cd0abc7ec6495416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3fc260a4b129770cd0abc7ec6495416">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetTensorBuffer </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a storage buffer in Tensor's data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointter to the destination of the pointer to the data storage buffer </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>The life of the storage buffer that can be obtained with Buffer is valid until either ailiaTFLiteAllocateTensors/ailiaTFLiteResizeInputTensor/ailiaTFLiteDestroy is called. The value of the storage buffer is changed when ailiaTFLitePredict is called. There is no need to open the storage buffer at the caller. </p>

</div>
</div>
<a id="a47c17b69682b9c2eb62224305d28ecbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c17b69682b9c2eb62224305d28ecbf">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorDimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetTensorDimension </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref Int32&#160;</td>
          <td class="paramname"><em>tensor_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dimension of index number Tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">tensor_dim</td><td>Pointter to the specified Tensor's dimension </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="a30893448fef225df072125b3d0db9dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30893448fef225df072125b3d0db9dce">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetTensorName </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref IntPtr&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the index number Tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">name</td><td>Pointter to the destination of the character string pointer named Tensor </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>The life of the string pointer that can be obtained in name is effective until calling ailiaTFLiteDestroy. There is no need to open the string pointer at the caller. </p>

</div>
</div>
<a id="ad675cc3dfe2912fc2fdf318068ca81d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad675cc3dfe2912fc2fdf318068ca81d2">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorQuantizationCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetTensorQuantizationCount </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref Int32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of quantified parameters of index number Tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">count</td><td>Pointter to the number of quantified parameters </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Get the number of quantified parameters associated with the specified Tensor. If there is no quantization parameter in the specified Tensor, 0 is stored. </p>

</div>
</div>
<a id="a7725f3fcc2100ee9d5dd2173cea2dd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7725f3fcc2100ee9d5dd2173cea2dd29">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorQuantizationQuantizedDimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetTensorQuantizationQuantizedDimension </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref Int32&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the axis of the integrated TENSOR quantization parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">axis</td><td>Pointter to the destination of the axis of the quantized parameter </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. If the quantized parameter does not exist in the specified Tensor, AILIA_TFLITE_STATUS_PARAMETER_NOT_FOUND is returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="a86c97829408d061fb051586b8488818a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c97829408d061fb051586b8488818a">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorQuantizationScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetTensorQuantizationScale </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float[]&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the scale of the quantified parameter of the index number TENSOR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">scale</td><td>Pointter to the storage destination of the quantized parameter </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. If the quantized parameter does not exist in the specified Tensor, AILIA_TFLITE_STATUS_PARAMETER_NOT_FOUND is returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Tensor is quantized and stored in the following formula. Quantization value = zero_point * round(input/scale) Acquired by scale: ailiaTFLiteGetTensorQuantizationScale Acquired by zero_point: ailiaTFliteGetTensorQuantizationZeroPoint scale should secure more than the number of elements obtained in ailiaTFLiteGetTensorQuantizationCount. </p>

</div>
</div>
<a id="a9bb252076a9f466c1511f9aa24e7c63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb252076a9f466c1511f9aa24e7c63f">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorQuantizationZeroPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetTensorQuantizationZeroPoint </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int64[]&#160;</td>
          <td class="paramname"><em>zero_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the zero point of the quantified parameter of the index number TENSOR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">zero_point</td><td>Pointter to the destination of zero points of quantization parameters </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. If the quantized parameter does not exist in the specified Tensor, AILIA_TFLITE_STATUS_PARAMETER_NOT_FOUND is returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>See ailiaTFLiteGetTensorQuantizationScale for description of quantification. For zero_point, secure a buffer that is more than the number of elements acquired in ailiaTFLiteGetTensorQuantizationCount. </p>

</div>
</div>
<a id="a332d99566bf2a4eb1c204242d6bc3e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a332d99566bf2a4eb1c204242d6bc3e04">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetTensorShape </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32[]&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the shape of the index number Tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">shape</td><td>Tensor shape storage destination </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Store the shape of the specified Tensor in Shape. Shape should secure a buffer that is more than the dimensions acquired by ailiaTFLiteGetTensorDimension. </p>

</div>
</div>
<a id="a1b60af1aae3826865a73b0b242a9bc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b60af1aae3826865a73b0b242a9bc69">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorShapeSignature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetTensorShapeSignature </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32[]&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the undecided dimensional form of Tensor of index number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">shape</td><td>Tensor shape storage destination </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Store the undecided dimensional information of the specified Tensor in Shape. -1 is stored for dimensions with undecided shape. If the specified Tensor does not contain an undecided dimension, it will be the same result as ailiaTFLiteGetTensorShape. Shape should secure a buffer that is more than the dimensions acquired by ailiaTFLiteGetTensorDimension. </p>

</div>
</div>
<a id="a78def8ebc21d320e827f34c3cdb57231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78def8ebc21d320e827f34c3cdb57231">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteGetTensorType </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref sbyte&#160;</td>
          <td class="paramname"><em>tensor_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Data type of TENSOR in Index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">tensor_type</td><td>Specified TENSOR data type storage destination </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="a8b6209e4877400f1401da1c87e101d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6209e4877400f1401da1c87e101d90">&#9670;&nbsp;</a></span>ailiaTFLiteGetVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr ailiaTFLite.AiliaTFLite.ailiaTFLiteGetVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the library version. </p>
<dl class="section return"><dt>Returns</dt><dd>Version number (can be converted to string with Marshal.PtrToStringAnsi)</dd></dl>
<p>The return value does not need to be released. </p>

</div>
</div>
<a id="aae7ea1137df13888dd7a8b080d447cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7ea1137df13888dd7a8b080d447cc4">&#9670;&nbsp;</a></span>ailiaTFLiteMklDisableFastMM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteMklDisableFastMM </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the mkl fastmm. </p>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>mkl_disable_fast_mm is called to disable FastMM.It affects all instances. Mkl increases the memory monotonously until mkl_Free_buffers is called to secure memory for each thread. This work memory is kept until mkl_Free_buffers is called in ailiaTFLiteDestroy. By disabling the fastmm, you can specify not to secure memory for each thread. In an environment that does not use Mkl (MacOS, etc.), return AILIA_TFLITE_STATUS_INVALID_STATE. </p>

</div>
</div>
<a id="a2d3a58e04451a1fe12124be27b0881b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3a58e04451a1fe12124be27b0881b0">&#9670;&nbsp;</a></span>ailiaTFLiteMklSetNumThreads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteMklSetNumThreads </td>
          <td>(</td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>num_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of threads used by MKL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_threads</td><td>Number of threads (1 or more) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Change the MKL thread number by calling mkl_set_num_threads.It affects all instances. By default, it will be automatically set. In an environment that does not use Mkl (MacOS, etc.), return AILIA_TFLITE_STATUS_INVALID_STATE. </p>

</div>
</div>
<a id="ae8bc6ebc4badf1c3cdc28b8c8e3c3108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8bc6ebc4badf1c3cdc28b8c8e3c3108">&#9670;&nbsp;</a></span>ailiaTFLitePredict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLitePredict </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do inference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="a1491072dfb32ce268cfeba254a22fcb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1491072dfb32ce268cfeba254a22fcb8">&#9670;&nbsp;</a></span>ailiaTFLiteResizeInputTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteResizeInputTensor </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>input_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32[]&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the shape of Tensor of the specified input index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">input_index</td><td>0 ~ Input Tensor number-1 </td></tr>
    <tr><td class="paramname">shape</td><td>New shape </td></tr>
    <tr><td class="paramname">dim</td><td>dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If the specified Tensor does not contain an undecided dimension, return AILIA_TFLITE_STATUS_FIXED_TENSOR. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Change the shape of the input Tensor. Calling this function to open the secured internal buffer You need to call ailiaTFLiteAllocateTensors. Also, since the shape of the intermediate Tensor may change depending on the input shape. After calling this function, the results of the acquisition API may be fraudulent until the ailiaTFLiteAllocateTensors is called. The upper limit of INDEX is <a class="el" href="classailiaTFLite_1_1AiliaTFLite.html#a24385f9c43317bb8219c0f22402491c8" title="Get the number of TENSOR in the TFLITE model.">ailiaTFLiteGetNumberOfInputs()</a> -1. If the specified Tensor does not contain an undecided dimension (if the Shape obtained in the ailiaTFLiteGetTensorShapeSignature does not include -1) will be an error. </p>

</div>
</div>
<a id="a63a7965f3c38b5f3911e8358c86a205b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a7965f3c38b5f3911e8358c86a205b">&#9670;&nbsp;</a></span>ailiaTFLiteSelectDevices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteSelectDevices </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32[]&#160;</td>
          <td class="paramname"><em>device_idxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt64&#160;</td>
          <td class="paramname"><em>idx_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the index of the device to use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">device_idxes</td><td>Arrangement with index number </td></tr>
    <tr><td class="paramname">idx_count</td><td>Number of arrays </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Specify the index of the device to use. Multiple specification can be specified. There are operators that are not implemented in NNAPI. Therefore, it is necessary to offload non compatible operators to CPU by specifying both DSP and CPU. </p>

</div>
</div>
<a id="ad57d878e3574616ddd829c98da1677f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57d878e3574616ddd829c98da1677f8">&#9670;&nbsp;</a></span>ailiaTFLiteSetCpuFeatures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteSetCpuFeatures </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>cpu_features</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the CPU instruction to use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">cpu_features</td><td>AILIA_TFLITE_CPU_FEATURES_XXX logical sum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Set the CPU instruction to use. If an unusable CPU instruction is set, return AILIA_TFLITE_STATUS_OUT_OF_RANGE. </p>

</div>
</div>
<a id="aacedc064dca9aed31393a5dcc953784d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacedc064dca9aed31393a5dcc953784d">&#9670;&nbsp;</a></span>ailiaTFLiteSetProfileMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteSetProfileMode </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the profile mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">mode</td><td>Profile mode (AILIA_TFLITE_PROFILE_MODE_*) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Specify the profile mode.The default is invalid. When the profile mode is enabled, the profile result is added to the output of ailiaTFLiteGetSummary. It must be executed immediately after ailiaTFLiteCreate. If you call after ailiaTFLiteAllocateTensors, AILIA_TFLITE_STATUS_INVALID_STATE will be returned. </p>

</div>
</div>
<a id="a25a0e8cb6117e144c037b610d9550586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a0e8cb6117e144c037b610d9550586">&#9670;&nbsp;</a></span>ailiaTFLiteSetScratchBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 ailiaTFLite.AiliaTFLite.ailiaTFLiteSetScratchBuffer </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>int_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt64&#160;</td>
          <td class="paramname"><em>int_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>mid_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt64&#160;</td>
          <td class="paramname"><em>mid_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>ext_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt64&#160;</td>
          <td class="paramname"><em>ext_buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a scratch buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">int_buffer</td><td>Pointer to scratch buffer (L2) </td></tr>
    <tr><td class="paramname">int_buffer_size</td><td>Size of scratch buffer (L2) (64 byte or above) </td></tr>
    <tr><td class="paramname">mid_buffer</td><td>Pointer to scratch buffer (MSMC) </td></tr>
    <tr><td class="paramname">mid_buffer_size</td><td>Size of scratch buffer (MSMC) </td></tr>
    <tr><td class="paramname">ext_buffer</td><td>Pointer to scratch buffer (DDR) </td></tr>
    <tr><td class="paramname">ext_buffer_size</td><td>Size of scratch buffer (DDR)</td></tr>
  </table>
  </dd>
</dl>
<p>Set the scratch buffer used for mmalib.It is valid only when env_mmalib is specified. The alignment of the buffer is performed internally, so there is no need to consider alignment. If you specify 0 for a buffer size other than L2, you can disable the specified buffer. If you specify * env_mmalib, execute ailiaTFLiteAllocateTensors without calling this function, return AILIA_TFLITE_STATUS_INVALID_STATE. The scratch buffer can be changed each time ailiaTFLitePredict is called. However, the size of the scratch buffer must be the same as the value used in ailiaTFLiteAllocateTensors. Because it is used as a work area of non -permanent data, it is possible to give the same buffer to multiple instances for single threads. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2c8ba1170b23eff39f722dd25e22bf3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8ba1170b23eff39f722dd25e22bf3f">&#9670;&nbsp;</a></span>AILIA_TFLITE_CPU_FEATURES_AVX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const UInt32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_CPU_FEATURES_AVX =(0x00000008)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aae3a6b5603cb2ca0fb3a6da32d40c3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3a6b5603cb2ca0fb3a6da32d40c3bd">&#9670;&nbsp;</a></span>AILIA_TFLITE_CPU_FEATURES_AVX2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const UInt32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_CPU_FEATURES_AVX2 =(0x00000010)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a05517e60528ac6483e197882ccaa9d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05517e60528ac6483e197882ccaa9d9d">&#9670;&nbsp;</a></span>AILIA_TFLITE_CPU_FEATURES_NEON</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const UInt32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_CPU_FEATURES_NEON =(0x00000001)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed32265479495ecec8965aaa4a780d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed32265479495ecec8965aaa4a780d7a">&#9670;&nbsp;</a></span>AILIA_TFLITE_CPU_FEATURES_NONE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const UInt32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_CPU_FEATURES_NONE =(0x00000000)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3502e306d8ed3a67d910a938bdb02798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3502e306d8ed3a67d910a938bdb02798">&#9670;&nbsp;</a></span>AILIA_TFLITE_CPU_FEATURES_SSE2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const UInt32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_CPU_FEATURES_SSE2 =(0x00000002)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a974cbf695d26cc47548b723e798e4dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974cbf695d26cc47548b723e798e4dd7">&#9670;&nbsp;</a></span>AILIA_TFLITE_CPU_FEATURES_SSE4_2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const UInt32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_CPU_FEATURES_SSE4_2 =(0x00000004)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaae339652ad5196d43753bfb001128de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae339652ad5196d43753bfb001128de">&#9670;&nbsp;</a></span>AILIA_TFLITE_CPU_FEATURES_VNNI</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const UInt32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_CPU_FEATURES_VNNI =(0x00000020)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afdee302a310f5b3eb98f0ff0fb721ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdee302a310f5b3eb98f0ff0fb721ee2">&#9670;&nbsp;</a></span>AILIA_TFLITE_ENV_MMALIB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_ENV_MMALIB =( 2)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0534b59fd05c17763f680f07bc5baa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0534b59fd05c17763f680f07bc5baa3">&#9670;&nbsp;</a></span>AILIA_TFLITE_ENV_MMALIB_COMPATIBLE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_ENV_MMALIB_COMPATIBLE =( 3)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06a494804119cd442387ca642d6c3c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a494804119cd442387ca642d6c3c67">&#9670;&nbsp;</a></span>AILIA_TFLITE_ENV_NNAPI</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_ENV_NNAPI =( 1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a15faf8b6ae7f09033c8bbdc65869bd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15faf8b6ae7f09033c8bbdc65869bd86">&#9670;&nbsp;</a></span>AILIA_TFLITE_ENV_REFERENCE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_ENV_REFERENCE =( 0)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad568df436230c4dc073d180b2c4695a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad568df436230c4dc073d180b2c4695a8">&#9670;&nbsp;</a></span>AILIA_TFLITE_FLAG_INPUT_AND_OUTPUT_TENSORS_USE_SCRATCH</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const UInt32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_FLAG_INPUT_AND_OUTPUT_TENSORS_USE_SCRATCH =( 1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cd56b5ac33c8b3476d1c8b5092b022c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd56b5ac33c8b3476d1c8b5092b022c">&#9670;&nbsp;</a></span>AILIA_TFLITE_FLAG_NONE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const UInt32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_FLAG_NONE =( 0)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa880471a31408f974f8270f5b2c0ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa880471a31408f974f8270f5b2c0ada">&#9670;&nbsp;</a></span>AILIA_TFLITE_MEMORY_MODE_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_MEMORY_MODE_DEFAULT =( 0)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1cd64b3267e61700d0881987556ec5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd64b3267e61700d0881987556ec5f3">&#9670;&nbsp;</a></span>AILIA_TFLITE_MEMORY_MODE_REDUCE_INTERSTAGE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_MEMORY_MODE_REDUCE_INTERSTAGE =( 1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5bd19c81a9dc7aaded9d380500207fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd19c81a9dc7aaded9d380500207fc4">&#9670;&nbsp;</a></span>AILIA_TFLITE_PROFILE_MODE_DISABLE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_PROFILE_MODE_DISABLE =( 0)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a8e1aac6c3d03d1103ca72ac1840ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8e1aac6c3d03d1103ca72ac1840ebf">&#9670;&nbsp;</a></span>AILIA_TFLITE_PROFILE_MODE_ENABLE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_PROFILE_MODE_ENABLE =( 1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae544ea8aab326a32719e1d0bf4f7a6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae544ea8aab326a32719e1d0bf4f7a6b2">&#9670;&nbsp;</a></span>AILIA_TFLITE_PROFILE_MODE_MEMORY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_PROFILE_MODE_MEMORY =( 4)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c4132271e5372f4fd0767f6c0012bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4132271e5372f4fd0767f6c0012bfb">&#9670;&nbsp;</a></span>AILIA_TFLITE_PROFILE_MODE_TRACE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_PROFILE_MODE_TRACE =( 2)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a53b2d4ea1afc1cbe8fac752fd62cf4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b2d4ea1afc1cbe8fac752fd62cf4d9">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_BROKEN_MODEL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_STATUS_BROKEN_MODEL =( -4)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4c3ef4510e92e0a9f05e5c69a48c1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c3ef4510e92e0a9f05e5c69a48c1ba">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_INVALID_ARGUMENT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_STATUS_INVALID_ARGUMENT =( -1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adc4bee81697d5cc30e5aa28efca018f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4bee81697d5cc30e5aa28efca018f6">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_INVALID_PARAMETER</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_STATUS_INVALID_PARAMETER =( -5)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afdce02eb28d01fcb943d24253ff8355e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdce02eb28d01fcb943d24253ff8355e">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_INVALID_STATE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_STATUS_INVALID_STATE =( -11)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a18285d00e2513e8dd7ab9f27560e79de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18285d00e2513e8dd7ab9f27560e79de">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_LICENSE_BROKEN</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_STATUS_LICENSE_BROKEN =( -9)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7319186274d06241d5189884e8becb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7319186274d06241d5189884e8becb8">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_LICENSE_EXPIRED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_STATUS_LICENSE_EXPIRED =( -10)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a327c0a483c7ca50a58af8e62a1363206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327c0a483c7ca50a58af8e62a1363206">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_LICENSE_NOT_FOUND</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_STATUS_LICENSE_NOT_FOUND =( -8)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac19bc164f32622a16e995d98ec2974ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19bc164f32622a16e995d98ec2974ad">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_MEMORY_INSUFFICIENT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_STATUS_MEMORY_INSUFFICIENT =( -3)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ce504dd854c09e3aa98ffc56f0e501f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce504dd854c09e3aa98ffc56f0e501f">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_OTHER_ERROR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_STATUS_OTHER_ERROR =(-128)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b5f04d2d998e295856cab9c3528c018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5f04d2d998e295856cab9c3528c018">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_OUT_OF_RANGE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_STATUS_OUT_OF_RANGE =( -2)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80d4e404e1f537d98418e0df911667db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d4e404e1f537d98418e0df911667db">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_PARAMETER_NOT_FOUND</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_STATUS_PARAMETER_NOT_FOUND =( -6)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1cd7d6f04e4797113de08db39c5f6c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd7d6f04e4797113de08db39c5f6c17">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_SUCCESS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_STATUS_SUCCESS =( 0)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9eaa85237328b48ad7aa0e6cd4892c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eaa85237328b48ad7aa0e6cd4892c06">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_UNSUPPORTED_OPCODE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_STATUS_UNSUPPORTED_OPCODE =( -7)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0383238abcb8e792c5a8ab0c049211a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0383238abcb8e792c5a8ab0c049211a9">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_BOOL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_TENSOR_TYPE_BOOL =( 6)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec298e888687e44f4eabcd05409743d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec298e888687e44f4eabcd05409743d0">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_COMPLEX64</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_TENSOR_TYPE_COMPLEX64 =( 8)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9fa05ecaf560a809162731ddff9dd473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa05ecaf560a809162731ddff9dd473">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_FLOAT16</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_TENSOR_TYPE_FLOAT16 =( 1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a249bb296bf247e96053d97373c18e0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249bb296bf247e96053d97373c18e0ec">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_FLOAT32</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_TENSOR_TYPE_FLOAT32 =( 0)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9553cd68853012670d0fb9f39162256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9553cd68853012670d0fb9f39162256">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_INT16</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_TENSOR_TYPE_INT16 =( 7)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1926bfe7a4efc83ec097d7fa0626858b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1926bfe7a4efc83ec097d7fa0626858b">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_INT32</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_TENSOR_TYPE_INT32 =( 2)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b84757f549ed1e98bbace73e41ccfc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b84757f549ed1e98bbace73e41ccfc6">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_INT64</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_TENSOR_TYPE_INT64 =( 4)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae83c7e50d6b0dce6a0d5caf85483b52b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83c7e50d6b0dce6a0d5caf85483b52b">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_INT8</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_TENSOR_TYPE_INT8 =( 9)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb2aa76d3c735180d6f078959f037ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2aa76d3c735180d6f078959f037ade">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_STRING</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_TENSOR_TYPE_STRING =( 5)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9fce41722ce0f3b61a7374b5e006194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9fce41722ce0f3b61a7374b5e006194">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_UINT8</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Int32 ailiaTFLite.AiliaTFLite.AILIA_TFLITE_TENSOR_TYPE_UINT8 =( 3)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab38b42b14ba66a50e5fa9014077b479f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38b42b14ba66a50e5fa9014077b479f">&#9670;&nbsp;</a></span>LIBRARY_NAME</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const String ailiaTFLite.AiliaTFLite.LIBRARY_NAME =&quot;ailia_tflite&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="AiliaTFLite_8cs.html">AiliaTFLite.cs</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
