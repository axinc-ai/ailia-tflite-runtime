<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ailia_tflite: ailia_tflite.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ailia_tflite
   &#160;<span id="projectnumber">1.2.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_cb031e414f281a658b23dddb30bb9d2c.html">runtime</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ailia_tflite.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>AILIA TFLITE RUNTIME INTERFACE.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for ailia_tflite.h:</div>
<div class="dyncontent">
<div class="center"><img src="ailia__tflite_8h__incl.png" border="0" usemap="#aailia__tflite_8h" alt=""/></div>
<map name="aailia__tflite_8h" id="aailia__tflite_8h">
<area shape="rect" title="AILIA TFLITE RUNTIME INTERFACE." alt="" coords="39,5,138,32"/>
<area shape="rect" title=" " alt="" coords="5,80,76,107"/>
<area shape="rect" title=" " alt="" coords="101,80,175,107"/>
</map>
</div>
</div>
<p><a href="ailia__tflite_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad870cf3a690f248a4cd8fdf567db5aff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#ad870cf3a690f248a4cd8fdf567db5aff">AILIA_TFLITE_TENSOR_TYPE_FLOAT32</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:ad870cf3a690f248a4cd8fdf567db5aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLOAT32.  <a href="ailia__tflite_8h.html#ad870cf3a690f248a4cd8fdf567db5aff">More...</a><br /></td></tr>
<tr class="separator:ad870cf3a690f248a4cd8fdf567db5aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513cb591edeca644dd24624e2acce014"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a513cb591edeca644dd24624e2acce014">AILIA_TFLITE_TENSOR_TYPE_FLOAT16</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:a513cb591edeca644dd24624e2acce014"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLOAT16.  <a href="ailia__tflite_8h.html#a513cb591edeca644dd24624e2acce014">More...</a><br /></td></tr>
<tr class="separator:a513cb591edeca644dd24624e2acce014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf94ba1c1b02014b6b0edfe4c4baab49"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#aaf94ba1c1b02014b6b0edfe4c4baab49">AILIA_TFLITE_TENSOR_TYPE_INT32</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="memdesc:aaf94ba1c1b02014b6b0edfe4c4baab49"><td class="mdescLeft">&#160;</td><td class="mdescRight">INT32.  <a href="ailia__tflite_8h.html#aaf94ba1c1b02014b6b0edfe4c4baab49">More...</a><br /></td></tr>
<tr class="separator:aaf94ba1c1b02014b6b0edfe4c4baab49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e43f5026fa1b0580e05ab65d3ef9ab0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a8e43f5026fa1b0580e05ab65d3ef9ab0">AILIA_TFLITE_TENSOR_TYPE_UINT8</a>&#160;&#160;&#160;(3)</td></tr>
<tr class="memdesc:a8e43f5026fa1b0580e05ab65d3ef9ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">UINT8.  <a href="ailia__tflite_8h.html#a8e43f5026fa1b0580e05ab65d3ef9ab0">More...</a><br /></td></tr>
<tr class="separator:a8e43f5026fa1b0580e05ab65d3ef9ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae518c4a92ffa28c8b9958d8be064edf4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#ae518c4a92ffa28c8b9958d8be064edf4">AILIA_TFLITE_TENSOR_TYPE_INT64</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="memdesc:ae518c4a92ffa28c8b9958d8be064edf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">INT64.  <a href="ailia__tflite_8h.html#ae518c4a92ffa28c8b9958d8be064edf4">More...</a><br /></td></tr>
<tr class="separator:ae518c4a92ffa28c8b9958d8be064edf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66fdd69441809c28d4078fd4fff3ced"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#af66fdd69441809c28d4078fd4fff3ced">AILIA_TFLITE_TENSOR_TYPE_STRING</a>&#160;&#160;&#160;(5)</td></tr>
<tr class="memdesc:af66fdd69441809c28d4078fd4fff3ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRING.  <a href="ailia__tflite_8h.html#af66fdd69441809c28d4078fd4fff3ced">More...</a><br /></td></tr>
<tr class="separator:af66fdd69441809c28d4078fd4fff3ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8695624dfcc13a733a0869ce7ec749fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a8695624dfcc13a733a0869ce7ec749fa">AILIA_TFLITE_TENSOR_TYPE_BOOL</a>&#160;&#160;&#160;(6)</td></tr>
<tr class="memdesc:a8695624dfcc13a733a0869ce7ec749fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">BOOL.  <a href="ailia__tflite_8h.html#a8695624dfcc13a733a0869ce7ec749fa">More...</a><br /></td></tr>
<tr class="separator:a8695624dfcc13a733a0869ce7ec749fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8c99d25ecf0c3eb9a0fb5105c2ac04"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a7b8c99d25ecf0c3eb9a0fb5105c2ac04">AILIA_TFLITE_TENSOR_TYPE_INT16</a>&#160;&#160;&#160;(7)</td></tr>
<tr class="memdesc:a7b8c99d25ecf0c3eb9a0fb5105c2ac04"><td class="mdescLeft">&#160;</td><td class="mdescRight">INT16.  <a href="ailia__tflite_8h.html#a7b8c99d25ecf0c3eb9a0fb5105c2ac04">More...</a><br /></td></tr>
<tr class="separator:a7b8c99d25ecf0c3eb9a0fb5105c2ac04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fafb53e13ad5f4d44018a35ba31ea39"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a0fafb53e13ad5f4d44018a35ba31ea39">AILIA_TFLITE_TENSOR_TYPE_COMPLEX64</a>&#160;&#160;&#160;(8)</td></tr>
<tr class="memdesc:a0fafb53e13ad5f4d44018a35ba31ea39"><td class="mdescLeft">&#160;</td><td class="mdescRight">COMPLEX64.  <a href="ailia__tflite_8h.html#a0fafb53e13ad5f4d44018a35ba31ea39">More...</a><br /></td></tr>
<tr class="separator:a0fafb53e13ad5f4d44018a35ba31ea39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eaa7789532ecc04ec3cc1741c092e13"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a3eaa7789532ecc04ec3cc1741c092e13">AILIA_TFLITE_TENSOR_TYPE_INT8</a>&#160;&#160;&#160;(9)</td></tr>
<tr class="memdesc:a3eaa7789532ecc04ec3cc1741c092e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">INT8.  <a href="ailia__tflite_8h.html#a3eaa7789532ecc04ec3cc1741c092e13">More...</a><br /></td></tr>
<tr class="separator:a3eaa7789532ecc04ec3cc1741c092e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afb121784e5ae2c153584bfeb242cab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a9afb121784e5ae2c153584bfeb242cab">AILIA_TFLITE_STATUS_SUCCESS</a>&#160;&#160;&#160;(   0)</td></tr>
<tr class="memdesc:a9afb121784e5ae2c153584bfeb242cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">成功  <a href="ailia__tflite_8h.html#a9afb121784e5ae2c153584bfeb242cab">More...</a><br /></td></tr>
<tr class="separator:a9afb121784e5ae2c153584bfeb242cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3523087fa3a9521bdfe5f821d290d3fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a3523087fa3a9521bdfe5f821d290d3fa">AILIA_TFLITE_STATUS_INVALID_ARGUMENT</a>&#160;&#160;&#160;(  -1)</td></tr>
<tr class="memdesc:a3523087fa3a9521bdfe5f821d290d3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the argument is fraudulent, if the status code is returned, review the caller code or the argument passed in NULL.  <a href="ailia__tflite_8h.html#a3523087fa3a9521bdfe5f821d290d3fa">More...</a><br /></td></tr>
<tr class="separator:a3523087fa3a9521bdfe5f821d290d3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06c2354ede3fd12b9e1b70c17b61f16"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#ab06c2354ede3fd12b9e1b70c17b61f16">AILIA_TFLITE_STATUS_OUT_OF_RANGE</a>&#160;&#160;&#160;(  -2)</td></tr>
<tr class="memdesc:ab06c2354ede3fd12b9e1b70c17b61f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the argument is out of range. returns this status code, please review whether the argument is out of the range.  <a href="ailia__tflite_8h.html#ab06c2354ede3fd12b9e1b70c17b61f16">More...</a><br /></td></tr>
<tr class="separator:ab06c2354ede3fd12b9e1b70c17b61f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44902c330bf1a87d15cba12d594002c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a44902c330bf1a87d15cba12d594002c9">AILIA_TFLITE_STATUS_MEMORY_INSUFFICIENT</a>&#160;&#160;&#160;(  -3)</td></tr>
<tr class="memdesc:a44902c330bf1a87d15cba12d594002c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This status code, which has a shortage of memory, is returned when the memory is secured.Check the availability of the memory and take action, such as terminating other processes.  <a href="ailia__tflite_8h.html#a44902c330bf1a87d15cba12d594002c9">More...</a><br /></td></tr>
<tr class="separator:a44902c330bf1a87d15cba12d594002c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7e456b323805fc51d67d839b35b0ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a1b7e456b323805fc51d67d839b35b0ec">AILIA_TFLITE_STATUS_BROKEN_MODEL</a>&#160;&#160;&#160;(  -4)</td></tr>
<tr class="memdesc:a1b7e456b323805fc51d67d839b35b0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This status code, which is damaged by the model, is returned when the given model file is damaged.Please check if the model file is correct.  <a href="ailia__tflite_8h.html#a1b7e456b323805fc51d67d839b35b0ec">More...</a><br /></td></tr>
<tr class="separator:a1b7e456b323805fc51d67d839b35b0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1a01d29cbb15beaff382daff89dda9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#afe1a01d29cbb15beaff382daff89dda9">AILIA_TFLITE_STATUS_INVALID_PARAMETER</a>&#160;&#160;&#160;(  -5)</td></tr>
<tr class="memdesc:afe1a01d29cbb15beaff382daff89dda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The model parameter is fraudulent This status code returns when the parameters contained in the model are fraudulent.Please check if the model file is correct.  <a href="ailia__tflite_8h.html#afe1a01d29cbb15beaff382daff89dda9">More...</a><br /></td></tr>
<tr class="separator:afe1a01d29cbb15beaff382daff89dda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6242d86d18b99327c1ecf28650e9e92"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#ae6242d86d18b99327c1ecf28650e9e92">AILIA_TFLITE_STATUS_PARAMETER_NOT_FOUND</a>&#160;&#160;&#160;(  -6)</td></tr>
<tr class="memdesc:ae6242d86d18b99327c1ecf28650e9e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">This status code without parameters is returned when the specified parameter does not exist in the model.Please check if the code or model file of the caller is correct.  <a href="ailia__tflite_8h.html#ae6242d86d18b99327c1ecf28650e9e92">More...</a><br /></td></tr>
<tr class="separator:ae6242d86d18b99327c1ecf28650e9e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d765c844c76712f90d8ea676e205f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#af9d765c844c76712f90d8ea676e205f1">AILIA_TFLITE_STATUS_UNSUPPORTED_OPCODE</a>&#160;&#160;&#160;(  -7)</td></tr>
<tr class="memdesc:af9d765c844c76712f90d8ea676e205f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This status code, which tried to run a non -brief -compatible operator, is returned when the ailia TFLite runtime is not supported.Make sure that the model is not included in the model other than the operator listed in the document.Please contact the documentary contact information for the addition of a new operator.  <a href="ailia__tflite_8h.html#af9d765c844c76712f90d8ea676e205f1">More...</a><br /></td></tr>
<tr class="separator:af9d765c844c76712f90d8ea676e205f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cae55222f1a317dc7b0995216a4205a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a7cae55222f1a317dc7b0995216a4205a">AILIA_TFLITE_STATUS_LICENSE_NOT_FOUND</a>&#160;&#160;&#160;(  -8)</td></tr>
<tr class="memdesc:a7cae55222f1a317dc7b0995216a4205a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This status code is not found in this status code when the trial version ailia TFLite runtime is running and if the license file is not found.For the trial version license, please contact the documentary inquiry.  <a href="ailia__tflite_8h.html#a7cae55222f1a317dc7b0995216a4205a">More...</a><br /></td></tr>
<tr class="separator:a7cae55222f1a317dc7b0995216a4205a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5775f36d3d9b641a7c416479f88e086d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a5775f36d3d9b641a7c416479f88e086d">AILIA_TFLITE_STATUS_LICENSE_BROKEN</a>&#160;&#160;&#160;(  -9)</td></tr>
<tr class="memdesc:a5775f36d3d9b641a7c416479f88e086d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This status code, which is broken, is returned when the license file is damaged when the trial version ailia TFLite runtime is running.For the trial version license, please contact the documentary inquiry.  <a href="ailia__tflite_8h.html#a5775f36d3d9b641a7c416479f88e086d">More...</a><br /></td></tr>
<tr class="separator:a5775f36d3d9b641a7c416479f88e086d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478f1a7e32a649fde27c4d6049ee4d36"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a478f1a7e32a649fde27c4d6049ee4d36">AILIA_TFLITE_STATUS_LICENSE_EXPIRED</a>&#160;&#160;&#160;( -10)</td></tr>
<tr class="memdesc:a478f1a7e32a649fde27c4d6049ee4d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">License expired status code is returned when the license file is expired when the trial version ailia TFLite runtime is running.Please contact the documentary contact information for updating the trial version license.  <a href="ailia__tflite_8h.html#a478f1a7e32a649fde27c4d6049ee4d36">More...</a><br /></td></tr>
<tr class="separator:a478f1a7e32a649fde27c4d6049ee4d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113f47f9552e9bafdbb6dd777cff6b61"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a113f47f9552e9bafdbb6dd777cff6b61">AILIA_TFLITE_STATUS_INVALID_STATE</a>&#160;&#160;&#160;( -11)</td></tr>
<tr class="memdesc:a113f47f9552e9bafdbb6dd777cff6b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this status code, which is not a state that can call the API, returns, review whether it can call the API.  <a href="ailia__tflite_8h.html#a113f47f9552e9bafdbb6dd777cff6b61">More...</a><br /></td></tr>
<tr class="separator:a113f47f9552e9bafdbb6dd777cff6b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe50eaadbb1d6a23b953fb85a87aa9b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#afe50eaadbb1d6a23b953fb85a87aa9b2">AILIA_TFLITE_STATUS_OTHER_ERROR</a>&#160;&#160;&#160;(-128)</td></tr>
<tr class="memdesc:afe50eaadbb1d6a23b953fb85a87aa9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns when an error other than the above occurs.Please contact us to the contact information described in the documentation.  <a href="ailia__tflite_8h.html#afe50eaadbb1d6a23b953fb85a87aa9b2">More...</a><br /></td></tr>
<tr class="separator:afe50eaadbb1d6a23b953fb85a87aa9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e3b6d361a1efbdc987de2d111f2d36"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#af7e3b6d361a1efbdc987de2d111f2d36">AILIA_TFLITE_ENV_REFERENCE</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:af7e3b6d361a1efbdc987de2d111f2d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference CPU implementation.  <a href="ailia__tflite_8h.html#af7e3b6d361a1efbdc987de2d111f2d36">More...</a><br /></td></tr>
<tr class="separator:af7e3b6d361a1efbdc987de2d111f2d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9688f63681246f827d2e763ea3c824"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a1d9688f63681246f827d2e763ea3c824">AILIA_TFLITE_ENV_NNAPI</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:a1d9688f63681246f827d2e763ea3c824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation using NNAPI.For Android.  <a href="ailia__tflite_8h.html#a1d9688f63681246f827d2e763ea3c824">More...</a><br /></td></tr>
<tr class="separator:a1d9688f63681246f827d2e763ea3c824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e32492fb3ee3b9f6a738583bcde0281"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a4e32492fb3ee3b9f6a738583bcde0281">AILIA_TFLITE_ENV_MMALIB</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="memdesc:a4e32492fb3ee3b9f6a738583bcde0281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation using mmalib.The PC uses mmalib emulator, and mmalib is used for the device.  <a href="ailia__tflite_8h.html#a4e32492fb3ee3b9f6a738583bcde0281">More...</a><br /></td></tr>
<tr class="separator:a4e32492fb3ee3b9f6a738583bcde0281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e3094b4b13b4d09b0a112a3dcd2841"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a07e3094b4b13b4d09b0a112a3dcd2841">AILIA_TFLITE_ENV_MMALIB_COMPATIBLE</a>&#160;&#160;&#160;(3)</td></tr>
<tr class="memdesc:a07e3094b4b13b4d09b0a112a3dcd2841"><td class="mdescLeft">&#160;</td><td class="mdescRight">MMALIB output compatible implementation.It operates at high speed to perform only the output match.  <a href="ailia__tflite_8h.html#a07e3094b4b13b4d09b0a112a3dcd2841">More...</a><br /></td></tr>
<tr class="separator:a07e3094b4b13b4d09b0a112a3dcd2841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af190565ac89b22388f7c260bc1cd7a17"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#af190565ac89b22388f7c260bc1cd7a17">AILIA_TFLITE_ENV_QNN</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="memdesc:af190565ac89b22388f7c260bc1cd7a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation using QNN.  <a href="ailia__tflite_8h.html#af190565ac89b22388f7c260bc1cd7a17">More...</a><br /></td></tr>
<tr class="separator:af190565ac89b22388f7c260bc1cd7a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8d55dee92592d1c76c918d7df506df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a2a8d55dee92592d1c76c918d7df506df">AILIA_TFLITE_MEMORY_MODE_DEFAULT</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:a2a8d55dee92592d1c76c918d7df506df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal mode.  <a href="ailia__tflite_8h.html#a2a8d55dee92592d1c76c918d7df506df">More...</a><br /></td></tr>
<tr class="separator:a2a8d55dee92592d1c76c918d7df506df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780c0d61c89ff31f6fe4a49ad66f5af5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a780c0d61c89ff31f6fe4a49ad66f5af5">AILIA_TFLITE_MEMORY_MODE_REDUCE_INTERSTAGE</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:a780c0d61c89ff31f6fe4a49ad66f5af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low Memory mode.  <a href="ailia__tflite_8h.html#a780c0d61c89ff31f6fe4a49ad66f5af5">More...</a><br /></td></tr>
<tr class="separator:a780c0d61c89ff31f6fe4a49ad66f5af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219b7975f284249f143f755e092b0f46"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a219b7975f284249f143f755e092b0f46">AILIA_TFLITE_PROFILE_MODE_DISABLE</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:a219b7975f284249f143f755e092b0f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Profile disabled.  <a href="ailia__tflite_8h.html#a219b7975f284249f143f755e092b0f46">More...</a><br /></td></tr>
<tr class="separator:a219b7975f284249f143f755e092b0f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bad4271bc400e42460de3befd3c4c9c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a9bad4271bc400e42460de3befd3c4c9c">AILIA_TFLITE_PROFILE_MODE_ENABLE</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:a9bad4271bc400e42460de3befd3c4c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Profile enabled.  <a href="ailia__tflite_8h.html#a9bad4271bc400e42460de3befd3c4c9c">More...</a><br /></td></tr>
<tr class="separator:a9bad4271bc400e42460de3befd3c4c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac545b2fcba61e640aa169435b69b638"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#aac545b2fcba61e640aa169435b69b638">AILIA_TFLITE_PROFILE_MODE_TRACE</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="memdesc:aac545b2fcba61e640aa169435b69b638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace enabled.  <a href="ailia__tflite_8h.html#aac545b2fcba61e640aa169435b69b638">More...</a><br /></td></tr>
<tr class="separator:aac545b2fcba61e640aa169435b69b638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1d851feb6ae6ab273fad7e67dc7194"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a4e1d851feb6ae6ab273fad7e67dc7194">AILIA_TFLITE_PROFILE_MODE_MEMORY</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="memdesc:a4e1d851feb6ae6ab273fad7e67dc7194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory profile enabled.  <a href="ailia__tflite_8h.html#a4e1d851feb6ae6ab273fad7e67dc7194">More...</a><br /></td></tr>
<tr class="separator:a4e1d851feb6ae6ab273fad7e67dc7194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714ed1a93d1cba0a9ad2d03253a4ae1b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a714ed1a93d1cba0a9ad2d03253a4ae1b">AILIA_TFLITE_PROFILE_MODE_SUB_CORE</a>&#160;&#160;&#160;(8)</td></tr>
<tr class="memdesc:a714ed1a93d1cba0a9ad2d03253a4ae1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sub core profile enabled.  <a href="ailia__tflite_8h.html#a714ed1a93d1cba0a9ad2d03253a4ae1b">More...</a><br /></td></tr>
<tr class="separator:a714ed1a93d1cba0a9ad2d03253a4ae1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f7ebfc640789fc98e49e646258375d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#ab5f7ebfc640789fc98e49e646258375d">AILIA_TFLITE_PROFILE_MODE_ALLOCATION</a>&#160;&#160;&#160;(16)</td></tr>
<tr class="memdesc:ab5f7ebfc640789fc98e49e646258375d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocation profile enabled.  <a href="ailia__tflite_8h.html#ab5f7ebfc640789fc98e49e646258375d">More...</a><br /></td></tr>
<tr class="separator:ab5f7ebfc640789fc98e49e646258375d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5b820429534167f552e5163be9ed11"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#aab5b820429534167f552e5163be9ed11">AILIA_TFLITE_FLAG_NONE</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:aab5b820429534167f552e5163be9ed11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal mode.  <a href="ailia__tflite_8h.html#aab5b820429534167f552e5163be9ed11">More...</a><br /></td></tr>
<tr class="separator:aab5b820429534167f552e5163be9ed11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97b13c2d8095832ff0da3ea1970bd7d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#ae97b13c2d8095832ff0da3ea1970bd7d">AILIA_TFLITE_FLAG_INPUT_AND_OUTPUT_TENSORS_USE_SCRATCH</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="separator:ae97b13c2d8095832ff0da3ea1970bd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bd39297c7b7fd8eaf28d0a833a4665"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#af4bd39297c7b7fd8eaf28d0a833a4665">AILIA_TFLITE_FLAG_DSA_FAST_MEMORY_ALLOCATION</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="memdesc:af4bd39297c7b7fd8eaf28d0a833a4665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate DSA memory with speed as the priority instead of memory usage.  <a href="ailia__tflite_8h.html#af4bd39297c7b7fd8eaf28d0a833a4665">More...</a><br /></td></tr>
<tr class="separator:af4bd39297c7b7fd8eaf28d0a833a4665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482796582d6a181a8c85404cee86aa91"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a482796582d6a181a8c85404cee86aa91">AILIA_TFLITE_CPU_FEATURES_NONE</a>&#160;&#160;&#160;(0x00000000)</td></tr>
<tr class="memdesc:a482796582d6a181a8c85404cee86aa91"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU extension disabled.  <a href="ailia__tflite_8h.html#a482796582d6a181a8c85404cee86aa91">More...</a><br /></td></tr>
<tr class="separator:a482796582d6a181a8c85404cee86aa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bd275d117bc876ec294fe8df2313e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#ac6bd275d117bc876ec294fe8df2313e9">AILIA_TFLITE_CPU_FEATURES_NEON</a>&#160;&#160;&#160;(0x00000001)</td></tr>
<tr class="memdesc:ac6bd275d117bc876ec294fe8df2313e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">NEON.  <a href="ailia__tflite_8h.html#ac6bd275d117bc876ec294fe8df2313e9">More...</a><br /></td></tr>
<tr class="separator:ac6bd275d117bc876ec294fe8df2313e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61acafd3093b58fc20a12dfe14c52c12"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a61acafd3093b58fc20a12dfe14c52c12">AILIA_TFLITE_CPU_FEATURES_SSE2</a>&#160;&#160;&#160;(0x00000002)</td></tr>
<tr class="memdesc:a61acafd3093b58fc20a12dfe14c52c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSE2.  <a href="ailia__tflite_8h.html#a61acafd3093b58fc20a12dfe14c52c12">More...</a><br /></td></tr>
<tr class="separator:a61acafd3093b58fc20a12dfe14c52c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8152dfaa8ce9220cb538b427d95cfed0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a8152dfaa8ce9220cb538b427d95cfed0">AILIA_TFLITE_CPU_FEATURES_SSE4_2</a>&#160;&#160;&#160;(0x00000004)</td></tr>
<tr class="memdesc:a8152dfaa8ce9220cb538b427d95cfed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSE4.2.  <a href="ailia__tflite_8h.html#a8152dfaa8ce9220cb538b427d95cfed0">More...</a><br /></td></tr>
<tr class="separator:a8152dfaa8ce9220cb538b427d95cfed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b46690cebd7ae7bbeceb838e39cef7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#ac6b46690cebd7ae7bbeceb838e39cef7">AILIA_TFLITE_CPU_FEATURES_AVX</a>&#160;&#160;&#160;(0x00000008)</td></tr>
<tr class="memdesc:ac6b46690cebd7ae7bbeceb838e39cef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">AVX.  <a href="ailia__tflite_8h.html#ac6b46690cebd7ae7bbeceb838e39cef7">More...</a><br /></td></tr>
<tr class="separator:ac6b46690cebd7ae7bbeceb838e39cef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c18888533e1caf20bc4932c8ab43d87"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a7c18888533e1caf20bc4932c8ab43d87">AILIA_TFLITE_CPU_FEATURES_AVX2</a>&#160;&#160;&#160;(0x00000010)</td></tr>
<tr class="memdesc:a7c18888533e1caf20bc4932c8ab43d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">AVX2.  <a href="ailia__tflite_8h.html#a7c18888533e1caf20bc4932c8ab43d87">More...</a><br /></td></tr>
<tr class="separator:a7c18888533e1caf20bc4932c8ab43d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3b45923806de93984d56e4eee0d8d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#afd3b45923806de93984d56e4eee0d8d5">AILIA_TFLITE_CPU_FEATURES_VNNI</a>&#160;&#160;&#160;(0x00000020)</td></tr>
<tr class="memdesc:afd3b45923806de93984d56e4eee0d8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">VNNI.  <a href="ailia__tflite_8h.html#afd3b45923806de93984d56e4eee0d8d5">More...</a><br /></td></tr>
<tr class="separator:afd3b45923806de93984d56e4eee0d8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0302dce720e9465f53aeb1b798b9b4b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#ad0302dce720e9465f53aeb1b798b9b4b">AILIA_TFLITE_CPU_FEATURES_AVX512</a>&#160;&#160;&#160;(0x00000040)</td></tr>
<tr class="memdesc:ad0302dce720e9465f53aeb1b798b9b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">AVX512.  <a href="ailia__tflite_8h.html#ad0302dce720e9465f53aeb1b798b9b4b">More...</a><br /></td></tr>
<tr class="separator:ad0302dce720e9465f53aeb1b798b9b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03324653e33020846f5697fef8d52fcf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a03324653e33020846f5697fef8d52fcf">AILIA_TFLITE_CPU_FEATURES_I8MM</a>&#160;&#160;&#160;(0x00000080)</td></tr>
<tr class="memdesc:a03324653e33020846f5697fef8d52fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">I8MM.  <a href="ailia__tflite_8h.html#a03324653e33020846f5697fef8d52fcf">More...</a><br /></td></tr>
<tr class="separator:a03324653e33020846f5697fef8d52fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101eea8befc393c6f9682efba16345e0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a101eea8befc393c6f9682efba16345e0">AILIA_TFLITE_SUB_CORE_COUNT_MAX</a>&#160;&#160;&#160;(8)</td></tr>
<tr class="memdesc:a101eea8befc393c6f9682efba16345e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of cores in multicore environments.  <a href="ailia__tflite_8h.html#a101eea8befc393c6f9682efba16345e0">More...</a><br /></td></tr>
<tr class="separator:a101eea8befc393c6f9682efba16345e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad484d38dd88bf46de076f88cc2bff74c"><td class="memItemLeft" align="right" valign="top">typedef int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#ad484d38dd88bf46de076f88cc2bff74c">AILIATFLiteTensorType</a></td></tr>
<tr class="separator:ad484d38dd88bf46de076f88cc2bff74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda2f6d89489d73ae1b983b2a8903cf2"><td class="memItemLeft" align="right" valign="top">typedef int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a></td></tr>
<tr class="separator:afda2f6d89489d73ae1b983b2a8903cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3efb8abac41021597407f121eed535d"><td class="memItemLeft" align="right" valign="top">typedef int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#ad3efb8abac41021597407f121eed535d">AILIATFLiteEnvironment</a></td></tr>
<tr class="separator:ad3efb8abac41021597407f121eed535d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c44ccf3ba49f821be2629bd3dcde53c"><td class="memItemLeft" align="right" valign="top">typedef int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a9c44ccf3ba49f821be2629bd3dcde53c">AILIATFLiteMemoryMode</a></td></tr>
<tr class="separator:a9c44ccf3ba49f821be2629bd3dcde53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102124bd44711479870d1515284d1a19"><td class="memItemLeft" align="right" valign="top">typedef int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a102124bd44711479870d1515284d1a19">AILIATFLiteFlags</a></td></tr>
<tr class="separator:a102124bd44711479870d1515284d1a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af403c38c72b52dcbceb46e62fc8f4561"><td class="memItemLeft" align="right" valign="top">typedef int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#af403c38c72b52dcbceb46e62fc8f4561">AILIATFLiteCpuFeatures</a></td></tr>
<tr class="separator:af403c38c72b52dcbceb46e62fc8f4561"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a11a709b1eb82ab242422fabdfc6bd73a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a11a709b1eb82ab242422fabdfc6bd73a">ailiaTFLiteGetEnvironmentCount</a> (size_t *env_count)</td></tr>
<tr class="memdesc:a11a709b1eb82ab242422fabdfc6bd73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of available calculation environments.  <a href="ailia__tflite_8h.html#a11a709b1eb82ab242422fabdfc6bd73a">More...</a><br /></td></tr>
<tr class="separator:a11a709b1eb82ab242422fabdfc6bd73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab507f9923493726ba96534d5419a1839"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#ab507f9923493726ba96534d5419a1839">ailiaTFLiteGetEnvironment</a> (<a class="el" href="ailia__tflite_8h.html#ad3efb8abac41021597407f121eed535d">AILIATFLiteEnvironment</a> *env)</td></tr>
<tr class="memdesc:ab507f9923493726ba96534d5419a1839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of calculation environments.  <a href="ailia__tflite_8h.html#ab507f9923493726ba96534d5419a1839">More...</a><br /></td></tr>
<tr class="separator:ab507f9923493726ba96534d5419a1839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033451378fff5cbd772c56df5325f382"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a033451378fff5cbd772c56df5325f382">ailiaTFLiteCreate</a> (struct AILIATFLiteInstance **instance, const void *tflite, const size_t tflite_length, void *(*pmalloc)(size_t, const void *, void *), void *(*pmemcpy)(void *, const void *, size_t, void *), void(*pfree)(void *, void *), void *phandle, <a class="el" href="ailia__tflite_8h.html#ad3efb8abac41021597407f121eed535d">AILIATFLiteEnvironment</a> env_id, <a class="el" href="ailia__tflite_8h.html#a9c44ccf3ba49f821be2629bd3dcde53c">AILIATFLiteMemoryMode</a> memory_mode, <a class="el" href="ailia__tflite_8h.html#a102124bd44711479870d1515284d1a19">AILIATFLiteFlags</a> flags)</td></tr>
<tr class="memdesc:a033451378fff5cbd772c56df5325f382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create ailia TFLite runtime instances.  <a href="ailia__tflite_8h.html#a033451378fff5cbd772c56df5325f382">More...</a><br /></td></tr>
<tr class="separator:a033451378fff5cbd772c56df5325f382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2762d4eab88139b057795b65afa3410f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a2762d4eab88139b057795b65afa3410f">ailiaTFLiteDestroy</a> (struct AILIATFLiteInstance *instance)</td></tr>
<tr class="memdesc:a2762d4eab88139b057795b65afa3410f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard the instance of ailia TFLite runtime.  <a href="ailia__tflite_8h.html#a2762d4eab88139b057795b65afa3410f">More...</a><br /></td></tr>
<tr class="separator:a2762d4eab88139b057795b65afa3410f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac89825fde2cae2116e18d2b057b7e7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#aac89825fde2cae2116e18d2b057b7e7f">ailiaTFLiteGetCpuFeatures</a> (struct AILIATFLiteInstance *instance, int32_t *cpu_features)</td></tr>
<tr class="memdesc:aac89825fde2cae2116e18d2b057b7e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the CPU instruction to use.  <a href="ailia__tflite_8h.html#aac89825fde2cae2116e18d2b057b7e7f">More...</a><br /></td></tr>
<tr class="separator:aac89825fde2cae2116e18d2b057b7e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf01e8e9893a604cabfd70c8df873d54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#abf01e8e9893a604cabfd70c8df873d54">ailiaTFLiteSetCpuFeatures</a> (struct AILIATFLiteInstance *instance, int32_t cpu_features)</td></tr>
<tr class="memdesc:abf01e8e9893a604cabfd70c8df873d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CPU instruction to use.  <a href="ailia__tflite_8h.html#abf01e8e9893a604cabfd70c8df873d54">More...</a><br /></td></tr>
<tr class="separator:abf01e8e9893a604cabfd70c8df873d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1f845d870f1bbd223d8e58fe31819c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#acc1f845d870f1bbd223d8e58fe31819c">ailiaTFLiteAllocateTensors</a> (struct AILIATFLiteInstance *instance)</td></tr>
<tr class="memdesc:acc1f845d870f1bbd223d8e58fe31819c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure the internal buffer of ailia TFLite runtime.  <a href="ailia__tflite_8h.html#acc1f845d870f1bbd223d8e58fe31819c">More...</a><br /></td></tr>
<tr class="separator:acc1f845d870f1bbd223d8e58fe31819c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea3823474e53affb293bf6f27f0d917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a2ea3823474e53affb293bf6f27f0d917">ailiaTFLiteResizeInputTensor</a> (struct AILIATFLiteInstance *instance, const int32_t input_index, const int32_t *shape, const int32_t dim)</td></tr>
<tr class="memdesc:a2ea3823474e53affb293bf6f27f0d917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the shape of Tensor of the specified input index.  <a href="ailia__tflite_8h.html#a2ea3823474e53affb293bf6f27f0d917">More...</a><br /></td></tr>
<tr class="separator:a2ea3823474e53affb293bf6f27f0d917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e53b6ce5e7b4aeb02796307379d618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a99e53b6ce5e7b4aeb02796307379d618">ailiaTFLiteGetNumberOfInputs</a> (const struct AILIATFLiteInstance *instance, int32_t *num_of_input_tensor)</td></tr>
<tr class="memdesc:a99e53b6ce5e7b4aeb02796307379d618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of TENSOR in the TFLITE model.  <a href="ailia__tflite_8h.html#a99e53b6ce5e7b4aeb02796307379d618">More...</a><br /></td></tr>
<tr class="separator:a99e53b6ce5e7b4aeb02796307379d618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b762bb33f7ce1cd61d321e76ccbbe7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a5b762bb33f7ce1cd61d321e76ccbbe7f">ailiaTFLiteGetInputTensorIndex</a> (const struct AILIATFLiteInstance *instance, int32_t *tensor_index, const int32_t input_index)</td></tr>
<tr class="memdesc:a5b762bb33f7ce1cd61d321e76ccbbe7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Tensor's index from index in Tensor.  <a href="ailia__tflite_8h.html#a5b762bb33f7ce1cd61d321e76ccbbe7f">More...</a><br /></td></tr>
<tr class="separator:a5b762bb33f7ce1cd61d321e76ccbbe7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5deecc950bcff5fd4eef168e3d801a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#abb5deecc950bcff5fd4eef168e3d801a">ailiaTFLiteGetNumberOfOutputs</a> (const struct AILIATFLiteInstance *instance, int32_t *num_of_output_tensor)</td></tr>
<tr class="memdesc:abb5deecc950bcff5fd4eef168e3d801a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of TENSOR of the TFLITE model.  <a href="ailia__tflite_8h.html#abb5deecc950bcff5fd4eef168e3d801a">More...</a><br /></td></tr>
<tr class="separator:abb5deecc950bcff5fd4eef168e3d801a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848dde61a3b163b4b71381c310439745"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a848dde61a3b163b4b71381c310439745">ailiaTFLiteGetOutputTensorIndex</a> (const struct AILIATFLiteInstance *instance, int32_t *tensor_index, const int32_t output_index)</td></tr>
<tr class="memdesc:a848dde61a3b163b4b71381c310439745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain Tensor's index from index of output Tensor.  <a href="ailia__tflite_8h.html#a848dde61a3b163b4b71381c310439745">More...</a><br /></td></tr>
<tr class="separator:a848dde61a3b163b4b71381c310439745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a75abd68011db5b3878ecf214a039d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a8a75abd68011db5b3878ecf214a039d2">ailiaTFLiteGetTensorDimension</a> (const struct AILIATFLiteInstance *instance, int32_t *tensor_dim, const int32_t tensor_index)</td></tr>
<tr class="memdesc:a8a75abd68011db5b3878ecf214a039d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of index number Tensor.  <a href="ailia__tflite_8h.html#a8a75abd68011db5b3878ecf214a039d2">More...</a><br /></td></tr>
<tr class="separator:a8a75abd68011db5b3878ecf214a039d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af662ecba3fc6103a517ecfe8c7605c7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#af662ecba3fc6103a517ecfe8c7605c7f">ailiaTFLiteGetTensorShape</a> (const struct AILIATFLiteInstance *instance, int32_t *shape, const int32_t tensor_index)</td></tr>
<tr class="memdesc:af662ecba3fc6103a517ecfe8c7605c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the shape of the index number Tensor.  <a href="ailia__tflite_8h.html#af662ecba3fc6103a517ecfe8c7605c7f">More...</a><br /></td></tr>
<tr class="separator:af662ecba3fc6103a517ecfe8c7605c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8405be45e8ff4be81f3917be287314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a8f8405be45e8ff4be81f3917be287314">ailiaTFLiteGetTensorShapeSignature</a> (const struct AILIATFLiteInstance *instance, int32_t *shape, const int32_t tensor_index)</td></tr>
<tr class="memdesc:a8f8405be45e8ff4be81f3917be287314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the undecided dimensional form of Tensor of index number.  <a href="ailia__tflite_8h.html#a8f8405be45e8ff4be81f3917be287314">More...</a><br /></td></tr>
<tr class="separator:a8f8405be45e8ff4be81f3917be287314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4d42e3f4862e4c43ed149394dc0654"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#aad4d42e3f4862e4c43ed149394dc0654">ailiaTFLiteGetTensorType</a> (const struct AILIATFLiteInstance *instance, <a class="el" href="ailia__tflite_8h.html#ad484d38dd88bf46de076f88cc2bff74c">AILIATFLiteTensorType</a> *tensor_type, const int32_t tensor_index)</td></tr>
<tr class="memdesc:aad4d42e3f4862e4c43ed149394dc0654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Data type of TENSOR in Index.  <a href="ailia__tflite_8h.html#aad4d42e3f4862e4c43ed149394dc0654">More...</a><br /></td></tr>
<tr class="separator:aad4d42e3f4862e4c43ed149394dc0654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d4e8d61f104aba9fddc94a5d3ffeeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#ae3d4e8d61f104aba9fddc94a5d3ffeeb">ailiaTFLiteGetTensorBuffer</a> (struct AILIATFLiteInstance *instance, void **buffer, const int32_t tensor_index)</td></tr>
<tr class="memdesc:ae3d4e8d61f104aba9fddc94a5d3ffeeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a storage buffer in Tensor's data.  <a href="ailia__tflite_8h.html#ae3d4e8d61f104aba9fddc94a5d3ffeeb">More...</a><br /></td></tr>
<tr class="separator:ae3d4e8d61f104aba9fddc94a5d3ffeeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777423cf731269609aef6fe4c620b542"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a777423cf731269609aef6fe4c620b542">ailiaTFLiteGetTensorName</a> (const struct AILIATFLiteInstance *instance, const char **name, const int32_t tensor_index)</td></tr>
<tr class="memdesc:a777423cf731269609aef6fe4c620b542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the index number Tensor.  <a href="ailia__tflite_8h.html#a777423cf731269609aef6fe4c620b542">More...</a><br /></td></tr>
<tr class="separator:a777423cf731269609aef6fe4c620b542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb222b42c49b9ed81eaab69638c5dda3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#abb222b42c49b9ed81eaab69638c5dda3">ailiaTFLiteGetTensorQuantizationCount</a> (const struct AILIATFLiteInstance *instance, int32_t *count, const int32_t tensor_index)</td></tr>
<tr class="memdesc:abb222b42c49b9ed81eaab69638c5dda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of quantified parameters of index number Tensor.  <a href="ailia__tflite_8h.html#abb222b42c49b9ed81eaab69638c5dda3">More...</a><br /></td></tr>
<tr class="separator:abb222b42c49b9ed81eaab69638c5dda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99de26ece390ea5d144bd5acea07fc11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a99de26ece390ea5d144bd5acea07fc11">ailiaTFLiteGetTensorQuantizationScale</a> (const struct AILIATFLiteInstance *instance, float *scale, const int32_t tensor_index)</td></tr>
<tr class="memdesc:a99de26ece390ea5d144bd5acea07fc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scale of the quantified parameter of the index number TENSOR.  <a href="ailia__tflite_8h.html#a99de26ece390ea5d144bd5acea07fc11">More...</a><br /></td></tr>
<tr class="separator:a99de26ece390ea5d144bd5acea07fc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63009ac208c3d191b530e0f01258c851"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a63009ac208c3d191b530e0f01258c851">ailiaTFLiteGetTensorQuantizationZeroPoint</a> (const struct AILIATFLiteInstance *instance, int64_t *zero_point, const int32_t tensor_index)</td></tr>
<tr class="memdesc:a63009ac208c3d191b530e0f01258c851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the zero point of the quantified parameter of the index number TENSOR.  <a href="ailia__tflite_8h.html#a63009ac208c3d191b530e0f01258c851">More...</a><br /></td></tr>
<tr class="separator:a63009ac208c3d191b530e0f01258c851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e21d85de94ef9221f7d082c7a618ef3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a7e21d85de94ef9221f7d082c7a618ef3">ailiaTFLiteGetTensorQuantizationQuantizedDimension</a> (const struct AILIATFLiteInstance *instance, int32_t *axis, const int32_t tensor_index)</td></tr>
<tr class="memdesc:a7e21d85de94ef9221f7d082c7a618ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the axis of the integrated TENSOR quantization parameter.  <a href="ailia__tflite_8h.html#a7e21d85de94ef9221f7d082c7a618ef3">More...</a><br /></td></tr>
<tr class="separator:a7e21d85de94ef9221f7d082c7a618ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1820b1dc49127cc614ad509e72e472d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#ab1820b1dc49127cc614ad509e72e472d">ailiaTFLitePredict</a> (struct AILIATFLiteInstance *instance)</td></tr>
<tr class="memdesc:ab1820b1dc49127cc614ad509e72e472d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do inference.  <a href="ailia__tflite_8h.html#ab1820b1dc49127cc614ad509e72e472d">More...</a><br /></td></tr>
<tr class="separator:ab1820b1dc49127cc614ad509e72e472d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0c3a183c8ed7e94d98f314757a5126"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a4a0c3a183c8ed7e94d98f314757a5126">ailiaTFLiteGetNodeCount</a> (const struct AILIATFLiteInstance *instance, int32_t *count)</td></tr>
<tr class="memdesc:a4a0c3a183c8ed7e94d98f314757a5126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of node.  <a href="ailia__tflite_8h.html#a4a0c3a183c8ed7e94d98f314757a5126">More...</a><br /></td></tr>
<tr class="separator:a4a0c3a183c8ed7e94d98f314757a5126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100750ed83c009c4e2a798075ebe3d50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a100750ed83c009c4e2a798075ebe3d50">ailiaTFLiteGetNodeOperator</a> (const struct AILIATFLiteInstance *instance, int32_t *op, const int32_t node_index)</td></tr>
<tr class="memdesc:a100750ed83c009c4e2a798075ebe3d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node_index number Operator.  <a href="ailia__tflite_8h.html#a100750ed83c009c4e2a798075ebe3d50">More...</a><br /></td></tr>
<tr class="separator:a100750ed83c009c4e2a798075ebe3d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d8b6ee7b318331bd657d476e89d9b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a36d8b6ee7b318331bd657d476e89d9b1">ailiaTFLiteGetNodeInputCount</a> (const struct AILIATFLiteInstance *instance, int32_t *count, const int32_t node_index)</td></tr>
<tr class="memdesc:a36d8b6ee7b318331bd657d476e89d9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node_index gets the number of node input.  <a href="ailia__tflite_8h.html#a36d8b6ee7b318331bd657d476e89d9b1">More...</a><br /></td></tr>
<tr class="separator:a36d8b6ee7b318331bd657d476e89d9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c33354afdac626be013d76bd638c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#ad5c33354afdac626be013d76bd638c82">ailiaTFLiteGetNodeInputTensorIndex</a> (const struct AILIATFLiteInstance *instance, int32_t *tensor_index, const int32_t node_index, const int32_t input_index)</td></tr>
<tr class="memdesc:ad5c33354afdac626be013d76bd638c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node_index Acquires the index of Tensor in the input input of node.  <a href="ailia__tflite_8h.html#ad5c33354afdac626be013d76bd638c82">More...</a><br /></td></tr>
<tr class="separator:ad5c33354afdac626be013d76bd638c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa57848491dd1ad11b549c981902d981"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#aaa57848491dd1ad11b549c981902d981">ailiaTFLiteGetNodeOutputCount</a> (const struct AILIATFLiteInstance *instance, int32_t *count, const int32_t node_index)</td></tr>
<tr class="memdesc:aaa57848491dd1ad11b549c981902d981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node_index gets the number of node output.  <a href="ailia__tflite_8h.html#aaa57848491dd1ad11b549c981902d981">More...</a><br /></td></tr>
<tr class="separator:aaa57848491dd1ad11b549c981902d981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540b22c72178236e44e360fa723cb11a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a540b22c72178236e44e360fa723cb11a">ailiaTFLiteGetNodeOutputTensorIndex</a> (const struct AILIATFLiteInstance *instance, int32_t *tensor_index, const int32_t node_index, const int32_t output_index)</td></tr>
<tr class="memdesc:a540b22c72178236e44e360fa723cb11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node_index Acquire the index of Tensor in the Output_index number of node.  <a href="ailia__tflite_8h.html#a540b22c72178236e44e360fa723cb11a">More...</a><br /></td></tr>
<tr class="separator:a540b22c72178236e44e360fa723cb11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ebebd2171386c11198ed01a6f35008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a96ebebd2171386c11198ed01a6f35008">ailiaTFLiteGetNodeOption</a> (const struct AILIATFLiteInstance *instance, void *value, const int32_t node_index, const char *key)</td></tr>
<tr class="memdesc:a96ebebd2171386c11198ed01a6f35008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node_index gets the Node option.  <a href="ailia__tflite_8h.html#a96ebebd2171386c11198ed01a6f35008">More...</a><br /></td></tr>
<tr class="separator:a96ebebd2171386c11198ed01a6f35008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe78851c83ea8b555bca91db03191c13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#abe78851c83ea8b555bca91db03191c13">ailiaTFLiteGetOperatorName</a> (const char **name, const int32_t op)</td></tr>
<tr class="memdesc:abe78851c83ea8b555bca91db03191c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Operator name.  <a href="ailia__tflite_8h.html#abe78851c83ea8b555bca91db03191c13">More...</a><br /></td></tr>
<tr class="separator:abe78851c83ea8b555bca91db03191c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6644208466e6ff60465b50554b88318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#ae6644208466e6ff60465b50554b88318">ailiaTFLiteSetProfileMode</a> (struct AILIATFLiteInstance *instance, int mode)</td></tr>
<tr class="memdesc:ae6644208466e6ff60465b50554b88318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the profile mode.  <a href="ailia__tflite_8h.html#ae6644208466e6ff60465b50554b88318">More...</a><br /></td></tr>
<tr class="separator:ae6644208466e6ff60465b50554b88318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b6a4c7ab20bc6285d0f030c49a551f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a31b6a4c7ab20bc6285d0f030c49a551f">ailiaTFLiteGetSummaryLength</a> (struct AILIATFLiteInstance *instance, size_t *buffer_size)</td></tr>
<tr class="memdesc:a31b6a4c7ab20bc6285d0f030c49a551f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the buffer required for network Summary.  <a href="ailia__tflite_8h.html#a31b6a4c7ab20bc6285d0f030c49a551f">More...</a><br /></td></tr>
<tr class="separator:a31b6a4c7ab20bc6285d0f030c49a551f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06cfe7964f7e91fcac4dac14c6d5ede"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#aa06cfe7964f7e91fcac4dac14c6d5ede">ailiaTFLiteGetSummary</a> (struct AILIATFLiteInstance *instance, char *buffer, size_t buffer_size)</td></tr>
<tr class="memdesc:aa06cfe7964f7e91fcac4dac14c6d5ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the name and shape of each node.  <a href="ailia__tflite_8h.html#aa06cfe7964f7e91fcac4dac14c6d5ede">More...</a><br /></td></tr>
<tr class="separator:aa06cfe7964f7e91fcac4dac14c6d5ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618d3addc7d3b9c224757fe77b435343"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a618d3addc7d3b9c224757fe77b435343">ailiaTFLiteGetErrorDetail</a> (struct AILIATFLiteInstance *instance, char **buffer)</td></tr>
<tr class="memdesc:a618d3addc7d3b9c224757fe77b435343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error details.  <a href="ailia__tflite_8h.html#a618d3addc7d3b9c224757fe77b435343">More...</a><br /></td></tr>
<tr class="separator:a618d3addc7d3b9c224757fe77b435343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b046dbdd3bd072f365523c14373cdd5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a6b046dbdd3bd072f365523c14373cdd5">ailiaTFLiteGetVersion</a> (void)</td></tr>
<tr class="memdesc:a6b046dbdd3bd072f365523c14373cdd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the version of the library.  <a href="ailia__tflite_8h.html#a6b046dbdd3bd072f365523c14373cdd5">More...</a><br /></td></tr>
<tr class="separator:a6b046dbdd3bd072f365523c14373cdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14ef38d13485d1c6dcd6046c54d880e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#af14ef38d13485d1c6dcd6046c54d880e">ailiaTFLiteSetScratchBuffer</a> (struct AILIATFLiteInstance *instance, void *int_buffer, size_t int_buffer_size, void *mid_buffer, size_t mid_buffer_size, void *ext_buffer, size_t ext_buffer_size)</td></tr>
<tr class="memdesc:af14ef38d13485d1c6dcd6046c54d880e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a scratch buffer.  <a href="ailia__tflite_8h.html#af14ef38d13485d1c6dcd6046c54d880e">More...</a><br /></td></tr>
<tr class="separator:af14ef38d13485d1c6dcd6046c54d880e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a11b9fa1ce2fd811b9804d41bc59900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a5a11b9fa1ce2fd811b9804d41bc59900">ailiaTFLiteSetScratchBufferEx</a> (struct AILIATFLiteInstance *instance, void *int_buffer, size_t int_buffer_size, void *mid_buffer, size_t mid_buffer_size, void *ext_buffer, size_t ext_buffer_size, void *global_buffer, size_t global_buffer_size)</td></tr>
<tr class="memdesc:a5a11b9fa1ce2fd811b9804d41bc59900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a scratch buffer (with Global MSMC)  <a href="ailia__tflite_8h.html#a5a11b9fa1ce2fd811b9804d41bc59900">More...</a><br /></td></tr>
<tr class="separator:a5a11b9fa1ce2fd811b9804d41bc59900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbab042e7225cd6ae27510d2a701dc27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#abbab042e7225cd6ae27510d2a701dc27">ailiaTFLiteGetScratchBufferUsage</a> (struct AILIATFLiteInstance *instance, size_t *int_buffer_size, size_t *mid_buffer_size, size_t *ext_buffer_size)</td></tr>
<tr class="memdesc:abbab042e7225cd6ae27510d2a701dc27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum usage of the scratch buffer.  <a href="ailia__tflite_8h.html#abbab042e7225cd6ae27510d2a701dc27">More...</a><br /></td></tr>
<tr class="separator:abbab042e7225cd6ae27510d2a701dc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a274001c5c986417efa6086d186f62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#ae1a274001c5c986417efa6086d186f62">ailiaTFLiteGetScratchBufferUsageEx</a> (struct AILIATFLiteInstance *instance, size_t *int_buffer_size, size_t *mid_buffer_size, size_t *ext_buffer_size, size_t *global_buffer_size)</td></tr>
<tr class="memdesc:ae1a274001c5c986417efa6086d186f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum usage of the scratch buffer.  <a href="ailia__tflite_8h.html#ae1a274001c5c986417efa6086d186f62">More...</a><br /></td></tr>
<tr class="separator:ae1a274001c5c986417efa6086d186f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ca4f49099ba34816b1e2c62b9dc62d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#ad2ca4f49099ba34816b1e2c62b9dc62d">ailiaTFLiteMklSetNumThreads</a> (const int32_t num_threads)</td></tr>
<tr class="memdesc:ad2ca4f49099ba34816b1e2c62b9dc62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of threads used by MKL.  <a href="ailia__tflite_8h.html#ad2ca4f49099ba34816b1e2c62b9dc62d">More...</a><br /></td></tr>
<tr class="separator:ad2ca4f49099ba34816b1e2c62b9dc62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a72d893963d90eebc881868d519a56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#aa4a72d893963d90eebc881868d519a56">ailiaTFLiteMklDisableFastMM</a> (void)</td></tr>
<tr class="memdesc:aa4a72d893963d90eebc881868d519a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the mkl fastmm.  <a href="ailia__tflite_8h.html#aa4a72d893963d90eebc881868d519a56">More...</a><br /></td></tr>
<tr class="separator:aa4a72d893963d90eebc881868d519a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643bbb31f1cfa0e5b0b23a654dc7fead"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a643bbb31f1cfa0e5b0b23a654dc7fead">ailiaTFLiteSetSynchronizeFunctions</a> (struct AILIATFLiteInstance *instance, int(*pmain_after_command_store)(void *), int(*pmain_before_state_load)(void *))</td></tr>
<tr class="separator:a643bbb31f1cfa0e5b0b23a654dc7fead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74905b627056e6342e090b5f40b46feb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a74905b627056e6342e090b5f40b46feb">alilaTFLiteSetSubCoreControlVariables</a> (struct AILIATFLiteInstance *instance, const struct AILIATFLiteSubCoreControlVariables *control_variables, int32_t sub_core_count)</td></tr>
<tr class="memdesc:a74905b627056e6342e090b5f40b46feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">When using multi-core systems, set the variables used to communicate with each subcore.  <a href="ailia__tflite_8h.html#a74905b627056e6342e090b5f40b46feb">More...</a><br /></td></tr>
<tr class="separator:a74905b627056e6342e090b5f40b46feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e49d04c6346c8a2cd65c9058ceea513"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a5e49d04c6346c8a2cd65c9058ceea513">ailiaTFLiteGetContext</a> (struct AILIATFLiteInstance *instance, void *buf, size_t buf_size)</td></tr>
<tr class="memdesc:a5e49d04c6346c8a2cd65c9058ceea513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the result of the DSA. <br  />
  <a href="ailia__tflite_8h.html#a5e49d04c6346c8a2cd65c9058ceea513">More...</a><br /></td></tr>
<tr class="separator:a5e49d04c6346c8a2cd65c9058ceea513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107162bbeca055f8b3d7e2ce079fe07b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#a107162bbeca055f8b3d7e2ce079fe07b">ailiaTFLiteGetContextSize</a> (struct AILIATFLiteInstance *instance, size_t *buf_size)</td></tr>
<tr class="memdesc:a107162bbeca055f8b3d7e2ce079fe07b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the buffer size (in bytes) required to save the results of the DSA. <br  />
  <a href="ailia__tflite_8h.html#a107162bbeca055f8b3d7e2ce079fe07b">More...</a><br /></td></tr>
<tr class="separator:a107162bbeca055f8b3d7e2ce079fe07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac072741989b4fbe60bc52c52b88cf6ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ailia__tflite_8h.html#ac072741989b4fbe60bc52c52b88cf6ee">ailiaTFLiteRestoreContext</a> (struct AILIATFLiteInstance *instance, const void *buf, size_t buf_size)</td></tr>
<tr class="memdesc:ac072741989b4fbe60bc52c52b88cf6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores the result of the DSA. <br  />
  <a href="ailia__tflite_8h.html#ac072741989b4fbe60bc52c52b88cf6ee">More...</a><br /></td></tr>
<tr class="separator:ac072741989b4fbe60bc52c52b88cf6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>AILIA TFLITE RUNTIME INTERFACE. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>AXELL CORPORATION, ax Inc. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 01, 2025 </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac6b46690cebd7ae7bbeceb838e39cef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b46690cebd7ae7bbeceb838e39cef7">&#9670;&nbsp;</a></span>AILIA_TFLITE_CPU_FEATURES_AVX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_CPU_FEATURES_AVX&#160;&#160;&#160;(0x00000008)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AVX. </p>

</div>
</div>
<a id="a7c18888533e1caf20bc4932c8ab43d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c18888533e1caf20bc4932c8ab43d87">&#9670;&nbsp;</a></span>AILIA_TFLITE_CPU_FEATURES_AVX2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_CPU_FEATURES_AVX2&#160;&#160;&#160;(0x00000010)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AVX2. </p>

</div>
</div>
<a id="ad0302dce720e9465f53aeb1b798b9b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0302dce720e9465f53aeb1b798b9b4b">&#9670;&nbsp;</a></span>AILIA_TFLITE_CPU_FEATURES_AVX512</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_CPU_FEATURES_AVX512&#160;&#160;&#160;(0x00000040)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AVX512. </p>

</div>
</div>
<a id="a03324653e33020846f5697fef8d52fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03324653e33020846f5697fef8d52fcf">&#9670;&nbsp;</a></span>AILIA_TFLITE_CPU_FEATURES_I8MM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_CPU_FEATURES_I8MM&#160;&#160;&#160;(0x00000080)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I8MM. </p>

</div>
</div>
<a id="ac6bd275d117bc876ec294fe8df2313e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bd275d117bc876ec294fe8df2313e9">&#9670;&nbsp;</a></span>AILIA_TFLITE_CPU_FEATURES_NEON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_CPU_FEATURES_NEON&#160;&#160;&#160;(0x00000001)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NEON. </p>

</div>
</div>
<a id="a482796582d6a181a8c85404cee86aa91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482796582d6a181a8c85404cee86aa91">&#9670;&nbsp;</a></span>AILIA_TFLITE_CPU_FEATURES_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_CPU_FEATURES_NONE&#160;&#160;&#160;(0x00000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CPU extension disabled. </p>

</div>
</div>
<a id="a61acafd3093b58fc20a12dfe14c52c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61acafd3093b58fc20a12dfe14c52c12">&#9670;&nbsp;</a></span>AILIA_TFLITE_CPU_FEATURES_SSE2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_CPU_FEATURES_SSE2&#160;&#160;&#160;(0x00000002)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SSE2. </p>

</div>
</div>
<a id="a8152dfaa8ce9220cb538b427d95cfed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8152dfaa8ce9220cb538b427d95cfed0">&#9670;&nbsp;</a></span>AILIA_TFLITE_CPU_FEATURES_SSE4_2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_CPU_FEATURES_SSE4_2&#160;&#160;&#160;(0x00000004)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SSE4.2. </p>

</div>
</div>
<a id="afd3b45923806de93984d56e4eee0d8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3b45923806de93984d56e4eee0d8d5">&#9670;&nbsp;</a></span>AILIA_TFLITE_CPU_FEATURES_VNNI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_CPU_FEATURES_VNNI&#160;&#160;&#160;(0x00000020)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VNNI. </p>

</div>
</div>
<a id="a4e32492fb3ee3b9f6a738583bcde0281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e32492fb3ee3b9f6a738583bcde0281">&#9670;&nbsp;</a></span>AILIA_TFLITE_ENV_MMALIB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_ENV_MMALIB&#160;&#160;&#160;(2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation using mmalib.The PC uses mmalib emulator, and mmalib is used for the device. </p>

</div>
</div>
<a id="a07e3094b4b13b4d09b0a112a3dcd2841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e3094b4b13b4d09b0a112a3dcd2841">&#9670;&nbsp;</a></span>AILIA_TFLITE_ENV_MMALIB_COMPATIBLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_ENV_MMALIB_COMPATIBLE&#160;&#160;&#160;(3)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MMALIB output compatible implementation.It operates at high speed to perform only the output match. </p>

</div>
</div>
<a id="a1d9688f63681246f827d2e763ea3c824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9688f63681246f827d2e763ea3c824">&#9670;&nbsp;</a></span>AILIA_TFLITE_ENV_NNAPI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_ENV_NNAPI&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation using NNAPI.For Android. </p>

</div>
</div>
<a id="af190565ac89b22388f7c260bc1cd7a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af190565ac89b22388f7c260bc1cd7a17">&#9670;&nbsp;</a></span>AILIA_TFLITE_ENV_QNN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_ENV_QNN&#160;&#160;&#160;(4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation using QNN. </p>

</div>
</div>
<a id="af7e3b6d361a1efbdc987de2d111f2d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e3b6d361a1efbdc987de2d111f2d36">&#9670;&nbsp;</a></span>AILIA_TFLITE_ENV_REFERENCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_ENV_REFERENCE&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference CPU implementation. </p>

</div>
</div>
<a id="af4bd39297c7b7fd8eaf28d0a833a4665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4bd39297c7b7fd8eaf28d0a833a4665">&#9670;&nbsp;</a></span>AILIA_TFLITE_FLAG_DSA_FAST_MEMORY_ALLOCATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_FLAG_DSA_FAST_MEMORY_ALLOCATION&#160;&#160;&#160;(2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate DSA memory with speed as the priority instead of memory usage. </p>

</div>
</div>
<a id="ae97b13c2d8095832ff0da3ea1970bd7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97b13c2d8095832ff0da3ea1970bd7d">&#9670;&nbsp;</a></span>AILIA_TFLITE_FLAG_INPUT_AND_OUTPUT_TENSORS_USE_SCRATCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_FLAG_INPUT_AND_OUTPUT_TENSORS_USE_SCRATCH&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab5b820429534167f552e5163be9ed11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5b820429534167f552e5163be9ed11">&#9670;&nbsp;</a></span>AILIA_TFLITE_FLAG_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_FLAG_NONE&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normal mode. </p>

</div>
</div>
<a id="a2a8d55dee92592d1c76c918d7df506df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8d55dee92592d1c76c918d7df506df">&#9670;&nbsp;</a></span>AILIA_TFLITE_MEMORY_MODE_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_MEMORY_MODE_DEFAULT&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normal mode. </p>

</div>
</div>
<a id="a780c0d61c89ff31f6fe4a49ad66f5af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780c0d61c89ff31f6fe4a49ad66f5af5">&#9670;&nbsp;</a></span>AILIA_TFLITE_MEMORY_MODE_REDUCE_INTERSTAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_MEMORY_MODE_REDUCE_INTERSTAGE&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low Memory mode. </p>

</div>
</div>
<a id="ab5f7ebfc640789fc98e49e646258375d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f7ebfc640789fc98e49e646258375d">&#9670;&nbsp;</a></span>AILIA_TFLITE_PROFILE_MODE_ALLOCATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_PROFILE_MODE_ALLOCATION&#160;&#160;&#160;(16)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocation profile enabled. </p>

</div>
</div>
<a id="a219b7975f284249f143f755e092b0f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219b7975f284249f143f755e092b0f46">&#9670;&nbsp;</a></span>AILIA_TFLITE_PROFILE_MODE_DISABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_PROFILE_MODE_DISABLE&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Profile disabled. </p>

</div>
</div>
<a id="a9bad4271bc400e42460de3befd3c4c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bad4271bc400e42460de3befd3c4c9c">&#9670;&nbsp;</a></span>AILIA_TFLITE_PROFILE_MODE_ENABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_PROFILE_MODE_ENABLE&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Profile enabled. </p>

</div>
</div>
<a id="a4e1d851feb6ae6ab273fad7e67dc7194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1d851feb6ae6ab273fad7e67dc7194">&#9670;&nbsp;</a></span>AILIA_TFLITE_PROFILE_MODE_MEMORY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_PROFILE_MODE_MEMORY&#160;&#160;&#160;(4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory profile enabled. </p>

</div>
</div>
<a id="a714ed1a93d1cba0a9ad2d03253a4ae1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714ed1a93d1cba0a9ad2d03253a4ae1b">&#9670;&nbsp;</a></span>AILIA_TFLITE_PROFILE_MODE_SUB_CORE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_PROFILE_MODE_SUB_CORE&#160;&#160;&#160;(8)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sub core profile enabled. </p>

</div>
</div>
<a id="aac545b2fcba61e640aa169435b69b638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac545b2fcba61e640aa169435b69b638">&#9670;&nbsp;</a></span>AILIA_TFLITE_PROFILE_MODE_TRACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_PROFILE_MODE_TRACE&#160;&#160;&#160;(2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trace enabled. </p>

</div>
</div>
<a id="a1b7e456b323805fc51d67d839b35b0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7e456b323805fc51d67d839b35b0ec">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_BROKEN_MODEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_STATUS_BROKEN_MODEL&#160;&#160;&#160;(  -4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This status code, which is damaged by the model, is returned when the given model file is damaged.Please check if the model file is correct. </p>

</div>
</div>
<a id="a3523087fa3a9521bdfe5f821d290d3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3523087fa3a9521bdfe5f821d290d3fa">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_INVALID_ARGUMENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_STATUS_INVALID_ARGUMENT&#160;&#160;&#160;(  -1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the argument is fraudulent, if the status code is returned, review the caller code or the argument passed in NULL. </p>

</div>
</div>
<a id="afe1a01d29cbb15beaff382daff89dda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1a01d29cbb15beaff382daff89dda9">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_INVALID_PARAMETER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_STATUS_INVALID_PARAMETER&#160;&#160;&#160;(  -5)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The model parameter is fraudulent This status code returns when the parameters contained in the model are fraudulent.Please check if the model file is correct. </p>

</div>
</div>
<a id="a113f47f9552e9bafdbb6dd777cff6b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113f47f9552e9bafdbb6dd777cff6b61">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_INVALID_STATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_STATUS_INVALID_STATE&#160;&#160;&#160;( -11)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If this status code, which is not a state that can call the API, returns, review whether it can call the API. </p>

</div>
</div>
<a id="a5775f36d3d9b641a7c416479f88e086d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5775f36d3d9b641a7c416479f88e086d">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_LICENSE_BROKEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_STATUS_LICENSE_BROKEN&#160;&#160;&#160;(  -9)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This status code, which is broken, is returned when the license file is damaged when the trial version ailia TFLite runtime is running.For the trial version license, please contact the documentary inquiry. </p>

</div>
</div>
<a id="a478f1a7e32a649fde27c4d6049ee4d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478f1a7e32a649fde27c4d6049ee4d36">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_LICENSE_EXPIRED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_STATUS_LICENSE_EXPIRED&#160;&#160;&#160;( -10)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>License expired status code is returned when the license file is expired when the trial version ailia TFLite runtime is running.Please contact the documentary contact information for updating the trial version license. </p>

</div>
</div>
<a id="a7cae55222f1a317dc7b0995216a4205a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cae55222f1a317dc7b0995216a4205a">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_LICENSE_NOT_FOUND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_STATUS_LICENSE_NOT_FOUND&#160;&#160;&#160;(  -8)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This status code is not found in this status code when the trial version ailia TFLite runtime is running and if the license file is not found.For the trial version license, please contact the documentary inquiry. </p>

</div>
</div>
<a id="a44902c330bf1a87d15cba12d594002c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44902c330bf1a87d15cba12d594002c9">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_MEMORY_INSUFFICIENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_STATUS_MEMORY_INSUFFICIENT&#160;&#160;&#160;(  -3)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This status code, which has a shortage of memory, is returned when the memory is secured.Check the availability of the memory and take action, such as terminating other processes. </p>

</div>
</div>
<a id="afe50eaadbb1d6a23b953fb85a87aa9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe50eaadbb1d6a23b953fb85a87aa9b2">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_OTHER_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_STATUS_OTHER_ERROR&#160;&#160;&#160;(-128)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns when an error other than the above occurs.Please contact us to the contact information described in the documentation. </p>

</div>
</div>
<a id="ab06c2354ede3fd12b9e1b70c17b61f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06c2354ede3fd12b9e1b70c17b61f16">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_OUT_OF_RANGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_STATUS_OUT_OF_RANGE&#160;&#160;&#160;(  -2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the argument is out of range. returns this status code, please review whether the argument is out of the range. </p>

</div>
</div>
<a id="ae6242d86d18b99327c1ecf28650e9e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6242d86d18b99327c1ecf28650e9e92">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_PARAMETER_NOT_FOUND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_STATUS_PARAMETER_NOT_FOUND&#160;&#160;&#160;(  -6)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This status code without parameters is returned when the specified parameter does not exist in the model.Please check if the code or model file of the caller is correct. </p>

</div>
</div>
<a id="a9afb121784e5ae2c153584bfeb242cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afb121784e5ae2c153584bfeb242cab">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_SUCCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_STATUS_SUCCESS&#160;&#160;&#160;(   0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>成功 </p>

</div>
</div>
<a id="af9d765c844c76712f90d8ea676e205f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d765c844c76712f90d8ea676e205f1">&#9670;&nbsp;</a></span>AILIA_TFLITE_STATUS_UNSUPPORTED_OPCODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_STATUS_UNSUPPORTED_OPCODE&#160;&#160;&#160;(  -7)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This status code, which tried to run a non -brief -compatible operator, is returned when the ailia TFLite runtime is not supported.Make sure that the model is not included in the model other than the operator listed in the document.Please contact the documentary contact information for the addition of a new operator. </p>

</div>
</div>
<a id="a101eea8befc393c6f9682efba16345e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101eea8befc393c6f9682efba16345e0">&#9670;&nbsp;</a></span>AILIA_TFLITE_SUB_CORE_COUNT_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_SUB_CORE_COUNT_MAX&#160;&#160;&#160;(8)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of cores in multicore environments. </p>

</div>
</div>
<a id="a8695624dfcc13a733a0869ce7ec749fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8695624dfcc13a733a0869ce7ec749fa">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_BOOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_TENSOR_TYPE_BOOL&#160;&#160;&#160;(6)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BOOL. </p>

</div>
</div>
<a id="a0fafb53e13ad5f4d44018a35ba31ea39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fafb53e13ad5f4d44018a35ba31ea39">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_COMPLEX64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_TENSOR_TYPE_COMPLEX64&#160;&#160;&#160;(8)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>COMPLEX64. </p>

</div>
</div>
<a id="a513cb591edeca644dd24624e2acce014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513cb591edeca644dd24624e2acce014">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_FLOAT16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_TENSOR_TYPE_FLOAT16&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FLOAT16. </p>

</div>
</div>
<a id="ad870cf3a690f248a4cd8fdf567db5aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad870cf3a690f248a4cd8fdf567db5aff">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_FLOAT32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_TENSOR_TYPE_FLOAT32&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FLOAT32. </p>

</div>
</div>
<a id="a7b8c99d25ecf0c3eb9a0fb5105c2ac04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8c99d25ecf0c3eb9a0fb5105c2ac04">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_INT16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_TENSOR_TYPE_INT16&#160;&#160;&#160;(7)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>INT16. </p>

</div>
</div>
<a id="aaf94ba1c1b02014b6b0edfe4c4baab49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf94ba1c1b02014b6b0edfe4c4baab49">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_INT32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_TENSOR_TYPE_INT32&#160;&#160;&#160;(2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>INT32. </p>

</div>
</div>
<a id="ae518c4a92ffa28c8b9958d8be064edf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae518c4a92ffa28c8b9958d8be064edf4">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_INT64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_TENSOR_TYPE_INT64&#160;&#160;&#160;(4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>INT64. </p>

</div>
</div>
<a id="a3eaa7789532ecc04ec3cc1741c092e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eaa7789532ecc04ec3cc1741c092e13">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_INT8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_TENSOR_TYPE_INT8&#160;&#160;&#160;(9)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>INT8. </p>

</div>
</div>
<a id="af66fdd69441809c28d4078fd4fff3ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66fdd69441809c28d4078fd4fff3ced">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_TENSOR_TYPE_STRING&#160;&#160;&#160;(5)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STRING. </p>

</div>
</div>
<a id="a8e43f5026fa1b0580e05ab65d3ef9ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e43f5026fa1b0580e05ab65d3ef9ab0">&#9670;&nbsp;</a></span>AILIA_TFLITE_TENSOR_TYPE_UINT8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AILIA_TFLITE_TENSOR_TYPE_UINT8&#160;&#160;&#160;(3)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UINT8. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="af403c38c72b52dcbceb46e62fc8f4561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af403c38c72b52dcbceb46e62fc8f4561">&#9670;&nbsp;</a></span>AILIATFLiteCpuFeatures</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t <a class="el" href="ailia__tflite_8h.html#af403c38c72b52dcbceb46e62fc8f4561">AILIATFLiteCpuFeatures</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3efb8abac41021597407f121eed535d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3efb8abac41021597407f121eed535d">&#9670;&nbsp;</a></span>AILIATFLiteEnvironment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t <a class="el" href="ailia__tflite_8h.html#ad3efb8abac41021597407f121eed535d">AILIATFLiteEnvironment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a102124bd44711479870d1515284d1a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102124bd44711479870d1515284d1a19">&#9670;&nbsp;</a></span>AILIATFLiteFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t <a class="el" href="ailia__tflite_8h.html#a102124bd44711479870d1515284d1a19">AILIATFLiteFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c44ccf3ba49f821be2629bd3dcde53c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c44ccf3ba49f821be2629bd3dcde53c">&#9670;&nbsp;</a></span>AILIATFLiteMemoryMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t <a class="el" href="ailia__tflite_8h.html#a9c44ccf3ba49f821be2629bd3dcde53c">AILIATFLiteMemoryMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afda2f6d89489d73ae1b983b2a8903cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda2f6d89489d73ae1b983b2a8903cf2">&#9670;&nbsp;</a></span>AILIATFLiteStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t <a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad484d38dd88bf46de076f88cc2bff74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad484d38dd88bf46de076f88cc2bff74c">&#9670;&nbsp;</a></span>AILIATFLiteTensorType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int8_t <a class="el" href="ailia__tflite_8h.html#ad484d38dd88bf46de076f88cc2bff74c">AILIATFLiteTensorType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acc1f845d870f1bbd223d8e58fe31819c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1f845d870f1bbd223d8e58fe31819c">&#9670;&nbsp;</a></span>ailiaTFLiteAllocateTensors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteAllocateTensors </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure the internal buffer of ailia TFLite runtime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Update the internal shape and secure the buffer required for inference. </p>

</div>
</div>
<a id="a033451378fff5cbd772c56df5325f382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033451378fff5cbd772c56df5325f382">&#9670;&nbsp;</a></span>ailiaTFLiteCreate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteCreate </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance **&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>tflite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>tflite_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(size_t, const void *, void *)&#160;</td>
          <td class="paramname"><em>pmalloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *, const void *, size_t, void *)&#160;</td>
          <td class="paramname"><em>pmemcpy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>pfree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>phandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ailia__tflite_8h.html#ad3efb8abac41021597407f121eed535d">AILIATFLiteEnvironment</a>&#160;</td>
          <td class="paramname"><em>env_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ailia__tflite_8h.html#a9c44ccf3ba49f821be2629bd3dcde53c">AILIATFLiteMemoryMode</a>&#160;</td>
          <td class="paramname"><em>memory_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ailia__tflite_8h.html#a102124bd44711479870d1515284d1a19">AILIATFLiteFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create ailia TFLite runtime instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime Pointter to instance pointer </td></tr>
    <tr><td class="paramname">tflite</td><td>Pointter to TFLITE model </td></tr>
    <tr><td class="paramname">tflite_length</td><td>TFLITE length (byte unit) </td></tr>
    <tr><td class="paramname">pmalloc</td><td>MALLOC function pointer (use malloc in the case of null) </td></tr>
    <tr><td class="paramname">pmemcpy</td><td>MEMCPY function pointer (use Memcpy for null) </td></tr>
    <tr><td class="paramname">pfree</td><td>FREE function pointer (use free in the case of null) </td></tr>
    <tr><td class="paramname">phandle</td><td>Handle passed to Memoria Locator (NULL when using standard allocator) </td></tr>
    <tr><td class="paramname">env_id</td><td>Progress execution environment used for calculation (AILIA_TFLITE_ENV_NAPI_*) </td></tr>
    <tr><td class="paramname">memory_mode</td><td>Memory mode (AILIA_TFLITE_MEMORY_MODE_*) </td></tr>
    <tr><td class="paramname">flags</td><td>Flag (logical sum of AILIA_TFLITE_FLAG_*) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Open the TFLITE model and create ailia TFLite runtime instances. We will also secure the necessary internal buffers. If the instance fails, you need to call AILIATFLITEDESTROY if you store anything other than NULL in Instance. </p>

</div>
</div>
<a id="a2762d4eab88139b057795b65afa3410f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2762d4eab88139b057795b65afa3410f">&#9670;&nbsp;</a></span>ailiaTFLiteDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ailiaTFLiteDestroy </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discard the instance of ailia TFLite runtime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e49d04c6346c8a2cd65c9058ceea513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e49d04c6346c8a2cd65c9058ceea513">&#9670;&nbsp;</a></span>ailiaTFLiteGetContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetContext </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the result of the DSA. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer <br  />
 </td></tr>
    <tr><td class="paramname">buf</td><td>Destination buffer <br  />
 </td></tr>
    <tr><td class="paramname">buf_size</td><td>Buffer size (in bytes) <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br  />
 Returns AILIA_TFLITE_STATUS_SUCCESS if successful. <br  />
 Returns AILIA_TFLITE_STATUS_XXX if failed. <br  />
</dd></dl>
<p><br  />
 Must be executed after calling ailiaTFLiteAllocateTensors. <br  />
 Saves the current DSA allocation state into the buffer, which can be reused when creating the next instance to reduce DSA allocation time. <br  />
 Saved results become invalid if the version of ailiaTFLiteRuntime changes. <br  />
 </p>

</div>
</div>
<a id="a107162bbeca055f8b3d7e2ce079fe07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107162bbeca055f8b3d7e2ce079fe07b">&#9670;&nbsp;</a></span>ailiaTFLiteGetContextSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetContextSize </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the buffer size (in bytes) required to save the results of the DSA. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer <br  />
 </td></tr>
    <tr><td class="paramname">buffer_size</td><td>Pointer to store the buffer size <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br  />
 Returns AILIA_TFLITE_STATUS_SUCCESS if successful. <br  />
 Returns AILIA_TFLITE_STATUS_XXX for other errors. <br  />
</dd></dl>
<p><br  />
 Must be executed after calling ailiaTFLiteAllocateTensors. <br  />
 </p>

</div>
</div>
<a id="aac89825fde2cae2116e18d2b057b7e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac89825fde2cae2116e18d2b057b7e7f">&#9670;&nbsp;</a></span>ailiaTFLiteGetCpuFeatures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetCpuFeatures </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>cpu_features</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the CPU instruction to use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">cpu_features</td><td>AILIA_TFLITE_CPU_FEATURES_XXX logical sum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Get the CPU instruction to use. By default, it returns the CPU instruction obtained from the CPU information. After calling ailiaTFLiteSetCpuFeatures, return the set CPU instruction. </p>

</div>
</div>
<a id="ab507f9923493726ba96534d5419a1839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab507f9923493726ba96534d5419a1839">&#9670;&nbsp;</a></span>ailiaTFLiteGetEnvironment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetEnvironment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ailia__tflite_8h.html#ad3efb8abac41021597407f121eed535d">AILIATFLiteEnvironment</a> *&#160;</td>
          <td class="paramname"><em>env</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of calculation environments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Arrangement of storage destination of calculation environmental information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Give the size of the <a class="el" href="ailia__tflite_8h.html#a11a709b1eb82ab242422fabdfc6bd73a" title="Get the number of available calculation environments.">ailiaTFLiteGetEnvironmentCount()</a> to input to the input. </p>

</div>
</div>
<a id="a11a709b1eb82ab242422fabdfc6bd73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a709b1eb82ab242422fabdfc6bd73a">&#9670;&nbsp;</a></span>ailiaTFLiteGetEnvironmentCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetEnvironmentCount </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>env_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of available calculation environments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env_count</td><td>Pointter to the number of calculation environment information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="a618d3addc7d3b9c224757fe77b435343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618d3addc7d3b9c224757fe77b435343">&#9670;&nbsp;</a></span>ailiaTFLiteGetErrorDetail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetErrorDetail </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the error details. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">buffer</td><td>Error detailed pointer to string</td></tr>
  </table>
  </dd>
</dl>
<p>The string does not need to be released. The validity period of the string is to call the AILIA API. </p>

</div>
</div>
<a id="a5b762bb33f7ce1cd61d321e76ccbbe7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b762bb33f7ce1cd61d321e76ccbbe7f">&#9670;&nbsp;</a></span>ailiaTFLiteGetInputTensorIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetInputTensorIndex </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>tensor_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>input_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Tensor's index from index in Tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Pointer to the destination of Tensor's index </td></tr>
    <tr><td class="paramname">input_index</td><td>INDEX of input Tensor (0 ~ Number of input Tensor-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If INPUT_INDEX is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Convert from index in Tensor to index of Tensor. The upper limit of INDEX is <a class="el" href="ailia__tflite_8h.html#a99e53b6ce5e7b4aeb02796307379d618" title="Get the number of TENSOR in the TFLITE model.">ailiaTFLiteGetNumberOfInputs()</a> -1. </p>

</div>
</div>
<a id="a4a0c3a183c8ed7e94d98f314757a5126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0c3a183c8ed7e94d98f314757a5126">&#9670;&nbsp;</a></span>ailiaTFLiteGetNodeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetNodeCount </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">count</td><td>Pointter to the number of node stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="a36d8b6ee7b318331bd657d476e89d9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d8b6ee7b318331bd657d476e89d9b1">&#9670;&nbsp;</a></span>ailiaTFLiteGetNodeInputCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetNodeInputCount </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>node_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node_index gets the number of node input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">count</td><td>Pointter to the storage destination of the number of input </td></tr>
    <tr><td class="paramname">node_index</td><td>Node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If node_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="ad5c33354afdac626be013d76bd638c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c33354afdac626be013d76bd638c82">&#9670;&nbsp;</a></span>ailiaTFLiteGetNodeInputTensorIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetNodeInputTensorIndex </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>tensor_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>node_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>input_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node_index Acquires the index of Tensor in the input input of node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Pointer to the destination of Tensor's index </td></tr>
    <tr><td class="paramname">node_index</td><td>Node index </td></tr>
    <tr><td class="paramname">input_index</td><td>INDEX for input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If node_index and input_index are out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="a100750ed83c009c4e2a798075ebe3d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100750ed83c009c4e2a798075ebe3d50">&#9670;&nbsp;</a></span>ailiaTFLiteGetNodeOperator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetNodeOperator </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>node_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get node_index number Operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">op</td><td>Pointter to the destination of Operator </td></tr>
    <tr><td class="paramname">node_index</td><td>Node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If node_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>The ENUM value of Operator is the same as the internal value of the TFLite file. For more information, see TensorFlow/Lite/Schema/Schema.fbs files in TensorFlow source tree. </p>

</div>
</div>
<a id="a96ebebd2171386c11198ed01a6f35008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ebebd2171386c11198ed01a6f35008">&#9670;&nbsp;</a></span>ailiaTFLiteGetNodeOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetNodeOption </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>node_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node_index gets the Node option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>aILIA TFLITE RUNTIME instance pointer </td></tr>
    <tr><td class="paramname">value</td><td>Pointter to the storage destination of the output </td></tr>
    <tr><td class="paramname">node_index</td><td>Node index </td></tr>
    <tr><td class="paramname">key</td><td>Optional name string pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If node_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="aaa57848491dd1ad11b549c981902d981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa57848491dd1ad11b549c981902d981">&#9670;&nbsp;</a></span>ailiaTFLiteGetNodeOutputCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetNodeOutputCount </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>node_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node_index gets the number of node output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">count</td><td>Pointter to the storage destination of the number of output </td></tr>
    <tr><td class="paramname">node_index</td><td>Node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If node_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="a540b22c72178236e44e360fa723cb11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540b22c72178236e44e360fa723cb11a">&#9670;&nbsp;</a></span>ailiaTFLiteGetNodeOutputTensorIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetNodeOutputTensorIndex </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>tensor_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>node_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>output_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node_index Acquire the index of Tensor in the Output_index number of node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Pointer to the destination of Tensor's index </td></tr>
    <tr><td class="paramname">node_index</td><td>Node index </td></tr>
    <tr><td class="paramname">output_index</td><td>Output index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If node_index and output_index are out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="a99e53b6ce5e7b4aeb02796307379d618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e53b6ce5e7b4aeb02796307379d618">&#9670;&nbsp;</a></span>ailiaTFLiteGetNumberOfInputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetNumberOfInputs </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>num_of_input_tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of TENSOR in the TFLITE model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">num_of_input_tensor</td><td>Pointter to the number of model input TENSOR </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="abb5deecc950bcff5fd4eef168e3d801a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5deecc950bcff5fd4eef168e3d801a">&#9670;&nbsp;</a></span>ailiaTFLiteGetNumberOfOutputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetNumberOfOutputs </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>num_of_output_tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of TENSOR of the TFLITE model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">num_of_output_tensor</td><td>Pointter to the number of model output TENSOR </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="abe78851c83ea8b555bca91db03191c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe78851c83ea8b555bca91db03191c13">&#9670;&nbsp;</a></span>ailiaTFLiteGetOperatorName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetOperatorName </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Operator name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointter to the destination of the string pointer with the name of Operator </td></tr>
    <tr><td class="paramname">op</td><td>Operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>The life of the character string pointer that can be obtained in Name is effective until the library unload. There is no need to open the string pointer at the caller. </p>

</div>
</div>
<a id="a848dde61a3b163b4b71381c310439745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848dde61a3b163b4b71381c310439745">&#9670;&nbsp;</a></span>ailiaTFLiteGetOutputTensorIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetOutputTensorIndex </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>tensor_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>output_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain Tensor's index from index of output Tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Pointer to the destination of Tensor's index </td></tr>
    <tr><td class="paramname">output_index</td><td>Output TENSOR index (0 ~ Number of output Tensor-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If output_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Convert from Index in Tensor to Tensor Index. The upper limit of INDEX is ailiaTFLiteGetNumberOfOutputs () -1. </p>

</div>
</div>
<a id="abbab042e7225cd6ae27510d2a701dc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbab042e7225cd6ae27510d2a701dc27">&#9670;&nbsp;</a></span>ailiaTFLiteGetScratchBufferUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetScratchBufferUsage </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>int_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>mid_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>ext_buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum usage of the scratch buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">int_buffer_size</td><td>Size of scratch buffer (L2) </td></tr>
    <tr><td class="paramname">mid_buffer_size</td><td>Size of scratch buffer (MSMC) </td></tr>
    <tr><td class="paramname">ext_buffer_size</td><td>Size of scratch buffer (DDR)</td></tr>
  </table>
  </dd>
</dl>
<p>You can get the size of the necessary scratch buffer by inferring in the first large scratch buffer size. Since the value considering the alignment performed inside is returned, the acquired value can be used directly without considering the alignment. </p>

</div>
</div>
<a id="ae1a274001c5c986417efa6086d186f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a274001c5c986417efa6086d186f62">&#9670;&nbsp;</a></span>ailiaTFLiteGetScratchBufferUsageEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetScratchBufferUsageEx </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>int_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>mid_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>ext_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>global_buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum usage of the scratch buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">int_buffer_size</td><td>Size of scratch buffer (L2) </td></tr>
    <tr><td class="paramname">mid_buffer_size</td><td>Size of scratch buffer (MSMC) </td></tr>
    <tr><td class="paramname">ext_buffer_size</td><td>Size of scratch buffer (DDR) </td></tr>
    <tr><td class="paramname">global_buffer_size</td><td>Size of scratch buffer (Global MSMC)</td></tr>
  </table>
  </dd>
</dl>
<p>You can get the size of the necessary scratch buffer by inferring in the first large scratch buffer size. Since the value considering the alignment performed inside is returned, the acquired value can be used directly without considering the alignment. </p>

</div>
</div>
<a id="aa06cfe7964f7e91fcac4dac14c6d5ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06cfe7964f7e91fcac4dac14c6d5ede">&#9670;&nbsp;</a></span>ailiaTFLiteGetSummary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetSummary </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the name and shape of each node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">buffer</td><td>SUMMARY output string pointer </td></tr>
    <tr><td class="paramname">buffer_size</td><td>The size of the output buffer (including the terminal NULL character).Set the value obtained by AILIATFLITITEGETSUMMARYLENGTH (). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="a31b6a4c7ab20bc6285d0f030c49a551f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b6a4c7ab20bc6285d0f030c49a551f">&#9670;&nbsp;</a></span>ailiaTFLiteGetSummaryLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetSummaryLength </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the buffer required for network Summary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">buffer_size</td><td>Pointter to the storage destination of the size of the buffer (including the terminal NULL character) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="ae3d4e8d61f104aba9fddc94a5d3ffeeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d4e8d61f104aba9fddc94a5d3ffeeb">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetTensorBuffer </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a storage buffer in Tensor's data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointter to the destination of the pointer to the data storage buffer </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>The life of the storage buffer that can be obtained with Buffer is valid until either ailiaTFLiteAllocateTensors/ailiaTFLiteResizeInputTensor/ailiaTFLiteDestroy is called. The value of the storage buffer is changed when ailiaTFLitePredict is called. There is no need to open the storage buffer at the caller. </p>

</div>
</div>
<a id="a8a75abd68011db5b3878ecf214a039d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a75abd68011db5b3878ecf214a039d2">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorDimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetTensorDimension </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>tensor_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dimension of index number Tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">tensor_dim</td><td>Pointter to the specified Tensor's dimension </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="a777423cf731269609aef6fe4c620b542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777423cf731269609aef6fe4c620b542">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetTensorName </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the index number Tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">name</td><td>Pointter to the destination of the character string pointer named Tensor </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>The life of the string pointer that can be obtained in name is effective until calling ailiaTFLiteDestroy. There is no need to open the string pointer at the caller. </p>

</div>
</div>
<a id="abb222b42c49b9ed81eaab69638c5dda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb222b42c49b9ed81eaab69638c5dda3">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorQuantizationCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetTensorQuantizationCount </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of quantified parameters of index number Tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">count</td><td>Pointter to the number of quantified parameters </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Get the number of quantified parameters associated with the specified Tensor. If there is no quantization parameter in the specified Tensor, 0 is stored. </p>

</div>
</div>
<a id="a7e21d85de94ef9221f7d082c7a618ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e21d85de94ef9221f7d082c7a618ef3">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorQuantizationQuantizedDimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetTensorQuantizationQuantizedDimension </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the axis of the integrated TENSOR quantization parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">axis</td><td>Pointter to the destination of the axis of the quantized parameter </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. If the quantized parameter does not exist in the specified Tensor, AILIA_TFLITE_STATUS_PARAMETER_NOT_FOUND is returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="a99de26ece390ea5d144bd5acea07fc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99de26ece390ea5d144bd5acea07fc11">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorQuantizationScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetTensorQuantizationScale </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the scale of the quantified parameter of the index number TENSOR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">scale</td><td>Pointter to the storage destination of the quantized parameter </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. If the quantized parameter does not exist in the specified Tensor, AILIA_TFLITE_STATUS_PARAMETER_NOT_FOUND is returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Tensor is quantized and stored in the following formula. Quantization value = zero_point * round(input/scale) Acquired by scale: ailiaTFLiteGetTensorQuantizationScale Acquired by zero_point: ailiaTFliteGetTensorQuantizationZeroPoint scale should secure more than the number of elements obtained in ailiaTFLiteGetTensorQuantizationCount. </p>

</div>
</div>
<a id="a63009ac208c3d191b530e0f01258c851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63009ac208c3d191b530e0f01258c851">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorQuantizationZeroPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetTensorQuantizationZeroPoint </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>zero_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the zero point of the quantified parameter of the index number TENSOR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">zero_point</td><td>Pointter to the destination of zero points of quantization parameters </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. If the quantized parameter does not exist in the specified Tensor, AILIA_TFLITE_STATUS_PARAMETER_NOT_FOUND is returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>See ailiaTFLiteGetTensorQuantizationScale for description of quantification. For zero_point, secure a buffer that is more than the number of elements acquired in ailiaTFLiteGetTensorQuantizationCountで. </p>

</div>
</div>
<a id="af662ecba3fc6103a517ecfe8c7605c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af662ecba3fc6103a517ecfe8c7605c7f">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetTensorShape </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the shape of the index number Tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">shape</td><td>Tensor shape storage destination </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Store the shape of the specified Tensor in Shape. Shape should secure a buffer that is more than the dimensions acquired by ailiaTFLiteGetTensorDimension. </p>

</div>
</div>
<a id="a8f8405be45e8ff4be81f3917be287314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8405be45e8ff4be81f3917be287314">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorShapeSignature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetTensorShapeSignature </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the undecided dimensional form of Tensor of index number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">shape</td><td>Tensor shape storage destination </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Store the undecided dimensional information of the specified Tensor in Shape. -1 is stored for dimensions with undecided shape. If the specified Tensor does not contain an undecided dimension, it will be the same result as ailiaTFLiteGetTensorShape. Shape should secure a buffer that is more than the dimensions acquired by ailiaTFLiteGetTensorDimension. </p>

</div>
</div>
<a id="aad4d42e3f4862e4c43ed149394dc0654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4d42e3f4862e4c43ed149394dc0654">&#9670;&nbsp;</a></span>ailiaTFLiteGetTensorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteGetTensorType </td>
          <td>(</td>
          <td class="paramtype">const struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ailia__tflite_8h.html#ad484d38dd88bf46de076f88cc2bff74c">AILIATFLiteTensorType</a> *&#160;</td>
          <td class="paramname"><em>tensor_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tensor_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Data type of TENSOR in Index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">tensor_type</td><td>Specified TENSOR data type storage destination </td></tr>
    <tr><td class="paramname">tensor_index</td><td>Tensor's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If Tensor_index is out of range, AILIA_TFLITE_STATUS_OUT_OF_RANGE will be returned. In the case of other errors, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="a6b046dbdd3bd072f365523c14373cdd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b046dbdd3bd072f365523c14373cdd5">&#9670;&nbsp;</a></span>ailiaTFLiteGetVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ailiaTFLiteGetVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the version of the library. </p>
<dl class="section return"><dt>Returns</dt><dd>Version number</dd></dl>
<p>The return value does not have to be released. </p>

</div>
</div>
<a id="aa4a72d893963d90eebc881868d519a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a72d893963d90eebc881868d519a56">&#9670;&nbsp;</a></span>ailiaTFLiteMklDisableFastMM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteMklDisableFastMM </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the mkl fastmm. </p>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>mkl_disable_fast_mm is called to disable FastMM.It affects all instances. Mkl increases the memory monotonously until mkl_Free_buffers is called to secure memory for each thread. This work memory is kept until mkl_Free_buffers is called in ailiaTFLiteDestroy. By disabling the fastmm, you can specify not to secure memory for each thread. In an environment that does not use Mkl (MacOS, etc.), return AILIA_TFLITE_STATUS_INVALID_STATE. </p>

</div>
</div>
<a id="ad2ca4f49099ba34816b1e2c62b9dc62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ca4f49099ba34816b1e2c62b9dc62d">&#9670;&nbsp;</a></span>ailiaTFLiteMklSetNumThreads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteMklSetNumThreads </td>
          <td>(</td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>num_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of threads used by MKL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_threads</td><td>Number of threads (1 or more) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Change the MKL thread number by calling mkl_set_num_threads.It affects all instances. By default, it will be automatically set. In an environment that does not use Mkl (MacOS, etc.), return AILIA_TFLITE_STATUS_INVALID_STATE. </p>

</div>
</div>
<a id="ab1820b1dc49127cc614ad509e72e472d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1820b1dc49127cc614ad509e72e472d">&#9670;&nbsp;</a></span>ailiaTFLitePredict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLitePredict </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do inference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX. </dd></dl>

</div>
</div>
<a id="a2ea3823474e53affb293bf6f27f0d917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea3823474e53affb293bf6f27f0d917">&#9670;&nbsp;</a></span>ailiaTFLiteResizeInputTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteResizeInputTensor </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>input_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the shape of Tensor of the specified input index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">input_index</td><td>0 ~ Input Tensor number-1 </td></tr>
    <tr><td class="paramname">shape</td><td>New shape </td></tr>
    <tr><td class="paramname">dim</td><td>dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If the specified Tensor does not contain an undecided dimension, return AILIA_TFLITE_STATUS_FIXED_TENSOR. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Change the shape of the input Tensor. Calling this function to open the secured internal buffer You need to call ailiaTFLiteAllocateTensors. Also, since the shape of the intermediate Tensor may change depending on the input shape. After calling this function, the results of the acquisition API may be fraudulent until the ailiaTFLiteAllocateTensors is called. The upper limit of INDEX is <a class="el" href="ailia__tflite_8h.html#a99e53b6ce5e7b4aeb02796307379d618" title="Get the number of TENSOR in the TFLITE model.">ailiaTFLiteGetNumberOfInputs()</a> -1. If the specified Tensor does not contain an undecided dimension (if the Shape obtained in the ailiaTFLiteGetTensorShapeSignature does not include -1) will be an error. </p>

</div>
</div>
<a id="ac072741989b4fbe60bc52c52b88cf6ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac072741989b4fbe60bc52c52b88cf6ee">&#9670;&nbsp;</a></span>ailiaTFLiteRestoreContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteRestoreContext </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restores the result of the DSA. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer <br  />
 </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer <br  />
 </td></tr>
    <tr><td class="paramname">buf_size</td><td>Buffer size (in bytes) <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br  />
 Returns AILIA_TFLITE_STATUS_SUCCESS if successful. <br  />
 Returns AILIA_TFLITE_STATUS_XXX if failed. <br  />
</dd></dl>
<p><br  />
 Must be executed before calling ailiaTFLiteAllocateTensors. <br  />
 By reusing the DSA allocation state saved in the buffer, the DSA allocation time can be reduced. <br  />
 Saved results become invalid if the version of ailiaTFLiteRuntime changes. <br  />
 </p>

</div>
</div>
<a id="abf01e8e9893a604cabfd70c8df873d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf01e8e9893a604cabfd70c8df873d54">&#9670;&nbsp;</a></span>ailiaTFLiteSetCpuFeatures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteSetCpuFeatures </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>cpu_features</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the CPU instruction to use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">cpu_features</td><td>AILIA_TFLITE_CPU_FEATURES_XXX logical sum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Set the CPU instruction to use. If an unusable CPU instruction is set, return AILIA_TFLITE_STATUS_OUT_OF_RANGE. </p>

</div>
</div>
<a id="ae6644208466e6ff60465b50554b88318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6644208466e6ff60465b50554b88318">&#9670;&nbsp;</a></span>ailiaTFLiteSetProfileMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteSetProfileMode </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the profile mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">mode</td><td>Profile mode (AILIA_TFLITE_PROFILE_MODE_*) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. In the case of other errors, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Specify the profile mode.The default is invalid. When the profile mode is enabled, the profile result is added to the output of ailiaTFLiteGetSummary. It must be executed immediately after ailiaTFLiteCreate. If you call after ailiaTFLiteAllocateTensors, AILIA_TFLITE_STATUS_INVALID_STATE will be returned. </p>

</div>
</div>
<a id="af14ef38d13485d1c6dcd6046c54d880e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14ef38d13485d1c6dcd6046c54d880e">&#9670;&nbsp;</a></span>ailiaTFLiteSetScratchBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteSetScratchBuffer </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>int_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>int_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mid_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mid_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ext_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ext_buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a scratch buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">int_buffer</td><td>Pointer to scratch buffer (L2) </td></tr>
    <tr><td class="paramname">int_buffer_size</td><td>Size of scratch buffer (L2) (64 byte or above) </td></tr>
    <tr><td class="paramname">mid_buffer</td><td>Pointer to scratch buffer (MSMC) </td></tr>
    <tr><td class="paramname">mid_buffer_size</td><td>Size of scratch buffer (MSMC) </td></tr>
    <tr><td class="paramname">ext_buffer</td><td>Pointer to scratch buffer (DDR) </td></tr>
    <tr><td class="paramname">ext_buffer_size</td><td>Size of scratch buffer (DDR)</td></tr>
  </table>
  </dd>
</dl>
<p>Set the scratch buffer used as an intermediate tensor and work memory. The alignment of the buffer is performed internally, so there is no need to consider alignment. If you specify 0 for a buffer size other than L2, you can disable the specified buffer. If you specify * env_mmalib, execute ailiaTFLiteAllocateTensors without calling this function, return AILIA_TFLITE_STATUS_INVALID_STATE. The scratch buffer can be changed each time ailiaTFLitePredict is called. However, the size of the scratch buffer must be the same as the value used in ailiaTFLiteAllocateTensors. Because it is used as a work area of non -permanent data, it is possible to give the same buffer to multiple instances for single threads. When the scratch buffer size changes, the attention tile size changes, and the processing results also change. </p>

</div>
</div>
<a id="a5a11b9fa1ce2fd811b9804d41bc59900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a11b9fa1ce2fd811b9804d41bc59900">&#9670;&nbsp;</a></span>ailiaTFLiteSetScratchBufferEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteSetScratchBufferEx </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>int_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>int_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mid_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mid_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ext_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ext_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>global_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>global_buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a scratch buffer (with Global MSMC) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">int_buffer</td><td>Pointer to scratch buffer (L2) </td></tr>
    <tr><td class="paramname">int_buffer_size</td><td>Size of scratch buffer (L2) (64 byte or above) </td></tr>
    <tr><td class="paramname">mid_buffer</td><td>Pointer to scratch buffer (MSMC) </td></tr>
    <tr><td class="paramname">mid_buffer_size</td><td>Size of scratch buffer (MSMC) </td></tr>
    <tr><td class="paramname">ext_buffer</td><td>Pointer to scratch buffer (DDR) </td></tr>
    <tr><td class="paramname">ext_buffer_size</td><td>Size of scratch buffer (DDR) </td></tr>
    <tr><td class="paramname">global_buffer</td><td>Pointer to scratch buffer (Global MSMC) </td></tr>
    <tr><td class="paramname">global_buffer_size</td><td>Size of scratch buffer (Global MSMC)</td></tr>
  </table>
  </dd>
</dl>
<p>This is a version of ailiaTFLiteSetScratchBuffer adapted for global MSMC. </p>

</div>
</div>
<a id="a643bbb31f1cfa0e5b0b23a654dc7fead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643bbb31f1cfa0e5b0b23a654dc7fead">&#9670;&nbsp;</a></span>ailiaTFLiteSetSynchronizeFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> ailiaTFLiteSetSynchronizeFunctions </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *)&#160;</td>
          <td class="paramname"><em>pmain_after_command_store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *)&#160;</td>
          <td class="paramname"><em>pmain_before_state_load</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74905b627056e6342e090b5f40b46feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74905b627056e6342e090b5f40b46feb">&#9670;&nbsp;</a></span>alilaTFLiteSetSubCoreControlVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ailia__tflite_8h.html#afda2f6d89489d73ae1b983b2a8903cf2">AILIATFLiteStatus</a> alilaTFLiteSetSubCoreControlVariables </td>
          <td>(</td>
          <td class="paramtype">struct AILIATFLiteInstance *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct AILIATFLiteSubCoreControlVariables *&#160;</td>
          <td class="paramname"><em>control_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sub_core_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When using multi-core systems, set the variables used to communicate with each subcore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ailia TFLite runtime instance pointer </td></tr>
    <tr><td class="paramname">control_variables</td><td>A pointer to the AILIATFLiteSubCoreControlVariables structure </td></tr>
    <tr><td class="paramname">sub_core_count</td><td>Number of sub-cores </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If you succeed, return AILIA_TFLITE_STATUS_SUCCESS. If you fail, return AILIA_TFLITE_STATUS_XXX.</dd></dl>
<p>Specify number of sub-cores to sub_core_count, and specify a structure array with sub_core_count elements to control_variables. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
